\chapter{Coq}\label{chap:coq}
U ovom poglavlju dajemo pregled visoke razine programskog sustava Coqa.
Prvo ćemo objasniti što je uopće Coq, u kojem je kontekstu nastao, i od kojih komponenti se sastoji.
Zatim ćemo dati kratak pregled programiranja u Coqu, nakon čega ćemo se baviti naprednijim konceptima i spomenuti neka ograničenja.
Za širi opseg gradiva, čitatelja upućujemo na knjige \textit{Coq'Art}~\cite{coqart}, \textit{Software Foundations}~\cite{sf-lf, sf-plf, sf-vfa} i \textit{Certified Programming with Dependent Types}~\cite{cpdt} te na službenu dokumentaciju~\cite{coqrefman}.

\section{Što je Coq?}\label{sec:osnovno-o-coqu}
Alat za dokazivanje Coq\footnote{\url{https://coq.inria.fr/}}, punog naziva \textit{The Coq Proof Assistant},
programski je sustav pomoću kojeg korisnici mogu dokazivati matematičke tvrdnje, a može se koristiti i kao funkcijski programski jezik sa zavisnim tipovima.
Alat se temelji na \(\lambda\)-računu i teoriji tipova, a prva je inačica implementirana 1984.~godine~\cite{coqrefman}
Ovaj rad koristi inačicu \(8.18\) iz rujna 2023.~godine.

Program Coq može se pokrenuti u interaktivnom ili u skupnom načinu rada.
Interaktivni način rada pokreće se naredbom \texttt{coqtop}, a korisniku omogućuje rad u ljusci sličnoj ljuskama \texttt{bash} i \texttt{python}.
Interaktivna ljuska (također poznata pod imenom \textit{toplevel}) služi unosu definicija te iskazivanju i dokazivanju tvrdnji.
Skupni način rada pokreće se naredbom \texttt{coqc}, a korisniku omogućuje semantičku provjeru i prevođenje izvornih datoteka u strojno čitljive formate.
Kod formaliziranja i dokazivanja, korisnik će najčešće koristiti interaktivni način rada, po mogućnosti kroz neku od dostupnih razvojnih okolina.\footnote{Autor rada koristio je paket \textit{Proof General} za uređivač teksta \textit{Emacs}. Druge često korištene okoline su \textit{VsCoq} i \textit{CoqIDE}.}

Kao programski jezik, Coq se sastoji od više podjezika različitih namjena, od kojih spominjemo \textit{Vernacular}, \textit{Gallinu} i \textit{Ltac}.
\begin{description}
\item[Vernacular] (\enquote{govorni jezik}) je jezik naredbi kojima korisnik komunicira sa sustavom (i u interaktivnom i u skupnom načinu rada);
  svaka Coq skripta (datoteka s nastavkom \texttt{.v}) je niz naredbi.
  Neke od najčešće korištenih naredbi su \texttt{Check}, \texttt{Definition}, \texttt{Inductive}, \texttt{Fixpoint} i \texttt{Lemma}.
  Pomoću naredbi za iskazivanje tvrdnji, kao što je \texttt{Lemma}, Coq ulazi u način dokazivanja~\engl{proof mode}.
\item[Gallina] je Coqov strogo statički tipiziran specifikacijski jezik.
  Dokazi svih tvrdnji predstavljeni su interno kao programi u Gallini.
  Kako se glavnina programiranja u Coqu svodi upravo na programiranje u Gallini, posvećujemo joj idući odjeljak.
\item[Ltac] je Coqov netipizirani jezik za definiciju i korištenje taktika.
  Taktike su pomoćne naredbe kojima se u načinu dokazivanja konstruira dokaz.
  Može se reći da je Ltac jezik za metaprogramiranje Galline.
  Primjeri taktika su \texttt{intros}, \texttt{destruct}, \texttt{apply} i \texttt{rewrite}.
\end{description} % https://coq.discourse.group/t/what-is-the-difference-between-gallina-and-ltac/1184 
\noindent Pogledajmo ilustrativan primjer.
\begin{minted}{coq}
  Lemma example_lemma: 1 + 1 = 2.
  Proof.
    cbn. reflexivity.
  Qed.
\end{minted}
\noindent Ključne riječi \texttt{Lemma}, \texttt{Proof} i \texttt{Qed} dio su Vernaculara,
izraz \texttt{example\_lemma:1+1=2} dio je Galline,
a pomoćne naredbe \texttt{cbn} i \texttt{reflexivity} dio su Ltaca.

Jezgra je programskog sustava Coq algoritam za provjeru tipova \engl{type checking} --- svaka tvrdnja koja se dokazuje iskazana je tipovima.
Ostatak sustava u načelu služi za knjigovodstvo i poboljšanje korisničkog iskustva.\footnote{I jezgra i ostatak sustava implementirani su u OCamlu.}
Nužno je da jezgra sustava bude relativno mala kako bismo se mogli uvjeriti u njenu točnost.
U suprotnom, možemo li biti sigurni da su naše dokazane tvrdnje doista istinite?

Prve inačice Coqa implementirale su samo račun konstrukcija~\cite{coc} ---
proširenje \(\lambda\)-računa polimorfnim i zavisnim tipovima te tipskim konstruktorima.
Kasnije je dodana podrška za induktivno i koinduktivno definirane tipove~\cite{cic, coinductive},
a danas se može reći da Coq implementira polimorfni kumulativni račun induktivnih konstrukcija~\cite{coqcoqcorrect}.
Coq se, osim kao dokazivač teorema, može koristiti i za programiranje sa zavisnim tipovima.
U toj sferi konkuriraju jezici Agda\footnote{\url{https://wiki.portal.chalmers.se/agda/}}, Idris\footnote{\url{https://www.idris-lang.org/}} i Lean\footnote{\url{https://lean-lang.org/}}. Coq se između njih ističe po usmjerenosti prema dokazivanju, posebno po korištenju taktika (jezik Ltac) i nepredikativnoj sorti \texttt{Prop} (o kojoj će kasnije biti riječi).
Još jedna prednost Coqa je mehanizam \textit{ekstrakcije} pomoću kojeg korisnik može proizvoljnu funkciju prevesti u jezik niže razine apstrakcije.\footnote{Trenutno su podržani Haskell, OCaml i Scheme.}
Mehanizam ekstrakcije nije dokazano točan, no poželjno je da izvorne funkcije budu ekvivalentne ekstrahiranima pa se radi na verifikaciji ekstrakcije~\cite{coqcoqcorrect}.

\section{Programiranje u Coqu}\label{sec:programiranje-u-gallini}
Gallina je funkcijski programski jezik, što znači da su funkcije prvoklasni objekti ---
one mogu biti argumenti i povratne vrijednosti drugih funkcija.
Dodatno, iteracija se ostvaruje rekurzijom te ne postoje tradicionalne varijable, već se koriste nepromjenjiva \engl{immutable} imena.
Za uvod u funkcijsko programiranje, čitatelja upućujemo na knjigu \textit{Programming in Haskell}~\cite{Hutton_2016}.
Primjeri koje ćemo vidjeti u ostatku ovog odjeljka oslanjanju se na tipove i funkcije definirane u Coqovoj standardnoj knjižnici.\footnote{\url{https://coq.inria.fr/library/}}

Gallina je strogo statički tipiziran jezik, što znači da se svakom termu prilikom prevođenja dodjeljuje tip\footnote{Tipovi su kolekcije objekata na kojima je moguće provoditi srodne operacije.}.
Naredbom \texttt{Check} možemo provjeriti tip nekog terma ili doznati da se termu ne može dodijeliti tip.
Dalje u radu pod \enquote{term} mislimo na dobro formirane terme, odnosno na one kojima se može dodijeliti tip.
Kažemo da je term \textit{stanovnik} tipa koji mu je dodijeljen.
Za tip kažemo da je \textit{nastanjen}, odnosno \textit{nenastanjen}, ako postoji, odnosno ne postoji, stanovnik tog tipa.
Kako su u Coqu i tipovi termi, radi razumljivosti i zvučnosti umjesto \enquote{tip tipa} kažemo \enquote{sorta tipa}.

Kao i u ostalim jezicima, kod programiranja u Coqu korisnik se oslanja na dostupne primitivne izraze,
od kojih su najvažniji:
\begin{itemize}
\item \texttt{forall} za konstrukciju funkcijskih tipova i zavisnih produkata, 
\item \texttt{match} za rad sa stanovnicima induktivnih tipova te
\item \texttt{fun}, \texttt{fix} i \texttt{cofix} za definiciju funkcija.
\end{itemize}

Naredbom \texttt{\textbf{Inductive}} definira se \textit{induktivni} tip te se automatski za njega generiraju principi \textit{indukcije} i \textit{rekurzije}.
\begin{minted}{coq}
Inductive nat : Set :=
| O : nat
| S : nat -> nat.
\end{minted}
\noindent Ovim kodom definirali smo tri terma:
\begin{itemize}
\item \texttt{nat} (tip prirodnih brojeva) je term sorte \texttt{Set},
\item \texttt{O} (broj nula) je term tipa \texttt{nat} i
\item \texttt{S} (funkcija sljedbenika) je term tipa \texttt{nat\(\rightarrow\)nat}.
\end{itemize}
\noindent Za term \texttt{nat} kažemo da je konstruktor tipa \engl{type constructor}, a za terme \texttt{O} i \texttt{S} kažemo da su konstruktori objekata \engl{object constructors}.


Jedna od osnovnih naredbi za imenovanje novih terma je naredba \texttt{Definition}.
\begin{minted}{coq}
Definition negb (b : bool) : bool :=
match b with
| false => true
| true => false
end.
\end{minted}
\noindent U gornjem kodu definirana je funkcija \texttt{negb} čiji se argument \texttt{b} tipa \texttt{bool} destrukturira te se vraća njegova negacija, također tipa \texttt{bool}.
Važno je napomenuti da izrazi koji počinju s \texttt{match t},
gdje je \texttt{t} stanovnik tipa \texttt{T}, moraju imati po jednu granu za svaki konstruktor tipa \texttt{T}.\footnote{U tandemu s uvjetom strukturalne rekurzije, ovime je osigurana totalnost svake funkcije.}
U ovom su primjeru konstante \texttt{false} i \texttt{true} jedini konstruktori tipa \textit{bool}.
Funkcija \texttt{negb} je tipa \texttt{bool\(\rightarrow\)bool}.
\begin{minted}{coq}
Definition mult_zero_r : Prop := forall (n : nat), n * 0 = 0.
\end{minted}
\noindent Ovdje je definirana propozicija (tip) imena \texttt{mult\_zero\_r} kao tvrdnja univerzalno kvantificirana po prirodnim brojevima.


Rekurzija nad induktivnim tipovima može se ostvariti naredbom \texttt{Fixpoint}, koja u pozadini koristi naredbu \texttt{Definition} te izraz \texttt{fix}.
\begin{minted}{coq}
Fixpoint plus (n m : nat) {struct n} : nat :=
(* Definition plus := fix plus (n m : nat) {struct n} := *)
match n with
| O => m
| S n' => S (plus n' m)
end.
\end{minted}
U ovom primjeru definirana je funkcija \texttt{plus} koja prima dva argumenta tipa \texttt{nat}.
Funkcija je rekurzivna s obzirom na prvi argument što je vidljivo iz oznake  \texttt{\{struct n\}}.
Napominjemo da su induktivni tipovi dobro utemeljeni, to jest svaki term induktivnog tipa je konačan.

Osim induktivnih, u Coqu postoje i koinduktivni tipovi, koji nisu dobro utemeljeni,
zbog čega za njih nije moguće definirati principe indukcije i rekurzije.
Umjesto rekurzije, koinduktivni tipovi koriste se u korekurzivnim funkcijama.
Standardan primjer koinduktivnog tipa je beskonačna lista.
\begin{minted}{coq}
Set Primitive Projections.
CoInductive Stream (A : Type) := Cons {
      hd : A;
      tl : Stream A;
    }.
\end{minted}
Ovime smo definirali familiju tipova \texttt{Stream} indeksiranu tipskom varijablom \texttt{A}.
Svaki \texttt{Stream} ima glavu i rep koji je također \texttt{Stream}.

Stanovnici koinduktivnih tipova konstruiraju se korekurzivnim funkcijama naredbom \texttt{CoFixpoint}, koja u pozadini koristi naredbu \texttt{Definition} te izraz \texttt{cofix}.
\begin{minted}{coq}
CoFixpoint from (n : nat) : Stream nat := Cons _ n (from (S n)).
(* Definition from := cofix from (n : nat) := Cons _ n (from (S n)) *)
\end{minted}
\noindent Ovime je definirana funkcija \texttt{from} koja za ulazni argument \texttt{n} vraća niz prirodnih brojeva od \(n\) na dalje.

Razlika induktivnih i koinduktivnih tipova može se sumirati epigramom:
\begin{displayquote}
  \enquote{Induktivni tipovi su domene rekurzivnih funkcija, koinduktivni tipovi su kodomene korekurzivnih funkcija}.
\end{displayquote}
\noindent Time se želi reći da se termi induktivnih tipova destrukturiraju u rekurzivnim funkcijama,
dok se termi koinduktivnih tipova konstruiraju u korekurzivnim funkcijama.

\section{Hijerarhija tipova}\label{sec:kumul-hijer-tipova}
U usporedbi s tradicionalnim programskim jezicima, Coqov tipski sustav je ekspresivniji jer dopušta tipove koji mogu ovisiti o termima.
Takvi tipovi se u Coqu konstruiraju izrazom oblika \texttt{forall}.
Primjer jednog takvog tipa je \enquote{lista duljine \(n\)},
gdje je \(n\) neki prirodan broj.
Njegovi su stanovnici \(n\)-torke, a on ovisi o stanovniku drugog tipa (u ovom slučaju, o \texttt{n} tipa \texttt{nat}).

Spomenuli smo da su i tipovi termi te im se može dodijeliti sorta.
Postoji li najveća sorta, odnosno postoji li tip \texttt{Type} čiji su stanovnici svi tipovi?
Prisjetimo se, svaki term ima svoj tip.
Kada bi takav \texttt{Type} postojao, tada bi vrijedilo \verb|Type:Type|, što može dovesti do paradoksa samoreferenciranja.\footnote{U naivnoj logici to je Epimenidov paradoks (\enquote{Ova je rečenica lažna.}), u naivnoj teoriji skupova to je Russellov paradoks, u naivnoj teoriji tipova to je Girardov paradoks.}
Takav dokazivač teorema bio bi inkonzistentan te bismo njime mogli dokazati kontradikciju, čime dokazivač efektivno gubi svoju svrhu.
Umjesto jedne \enquote{velike} sorte \texttt{Type}, u Coqu postoji rastući niz sorti \coqtype{n} za sve prirodne brojeve \(n\),
takav da vrijedi \(\coqtype{n} : \coqtype{m}\) kad god vrijedi \(n < m\).
Ilustracija ove \textbf{kumulativne hijerarhije tipova} prikazana je na slici~\ref{fig:kum-hijer-tip}.
Dvije najvažnije sorte u Coqu su \texttt{Set} i \texttt{Prop}.

\begin{figure}[htb]
  \centering
  \begin{forest}
    for tree={l sep+=5mm}
    [\vdots
    [\coqtype{m+1}
    [\ldots]
    [\texttt{bool\(\rightarrow\)\coqtype{m}}]
    [\coqtype{m} [\ldots][\vdots
    [\coqtype{1}
    [\coqset [\texttt{bool}\\ \texttt{nat}\\ \vdots, align=center, base=top] [\texttt{list nat}\\ \texttt{prod nat bool}\\ \texttt{nat\(\rightarrow\)nat}\\ \vdots{}, align=center, base=top] [\ldots]]
    [\texttt{bool}\(\rightarrow\)\coqset]
    [\ldots]
    [\coqprop [\texttt{True}\\ \texttt{1+1=2}\\ \vdots, align=center, base=top] [\texttt{False}\\ \texttt{\(\forall\)b,negb b=b}\\ \vdots, align=center, base=top] [\ldots]]
    [\texttt{nat}\(\rightarrow\)\coqprop]
    [\ldots]
    ]
    ] [\ldots]
    ] [\coqtype{m} \(\rightarrow\) \coqprop] [\ldots]]]
  \end{forest}
  \caption{Kumulativna hijerarhija tipova}\label{fig:kum-hijer-tip}
\end{figure}

Naziv \coqset{} sinonim je za sortu \coqtype{0}, a njene stanovnike zovemo \textbf{malim tipovima}.
Primjerice, tipovi \texttt{nat} i \texttt{bool} su mali tipovi.
Dodatno, tipovi funkcija koje primaju i vraćaju male tipove su također mali tipovi.
Također su i produkti, sume, liste i stabla malih tipova ponovo mali tipovi.
Intuitivno se može reći da su mali oni tipovi s čijim se stanovnicima može efektivno računati.
Stanovnike malih tipova nazivamo \textbf{programima}.

Stanovnici sorte \texttt{Prop} su \textbf{propozicije} (izjave).
Za razliku od programa, s propozicijama ne možemo efektivno računati, ali ih možemo dokazivati.
Stanovnici propozicija su njihovi \textbf{dokazi}.

Za dokazivače teorema, poželjna je mogućnost definicije predikata (propozicija) nad proizvoljnim tipovima.
Zbog toga u Coqu prilikom definicije terma sorte \coqprop možemo
kvantificirati po proizvoljno velikim tipovima, što uključuje i sortu \coqprop.
Tako je ovdje \texttt{not} predikat nad sortom \coqprop.
\begin{minted}{coq}
Definition not (P : Prop) := forall (Q : Prop), P -> Q.
\end{minted}
\noindent Valja primijetiti da kod definicije predikata \texttt{not} kvantificiramo po \coqprop{},
no za svaku propoziciju \texttt{P} je term \texttt{not P} također tipa \coqprop{}, pa
domena funkcije \texttt{not P} uključuje sam term \texttt{not P}.
Ovaj stil kvantifikacije omogućuje nam definiciju proizvoljnih propozicija i propozicijskih veznika.
Kažemo da je sorta \coqprop{} \textbf{nepredikativna}.
S druge strane, sorta \coqset{} je \textbf{predikativna}, to jest \textit{ne dopušta} kvantifikaciju po \coqset{} i ostalim proizvoljno velikim tipovima.
Kada bi sorta \coqprop{} bila predikativna, uopće ne bismo mogli definirati predikat \texttt{not}.

\section{Propozicije i tipovi, dokazi i termi}\label{sec:propozicije-i-tipovi}
U decimalnom zapisu broja \(\pi\), barem jedna znamenka pojavljuje se beskonačno mnogo puta.
Doista, kada bi se svaka znamenka pojavljivala samo konačno mnogo puta, broj \(\pi\) bio bi racionalan.
Međutim, nije jasno \textit{koja} znamenka ima to svojstvo.
Možda ih ima više. Štoviše, vjerujemo da su \textit{sve} znamenke takve.
Da bismo odgovorili na to pitanje, morali bismo prebrojiti sve znamenke broja \(\pi\),
što nije moguće u konačno mnogo koraka.

Sličnim pitanjima bavili su se logičari dvadesetog stoljeća. \textit{Klasični} logičari bi gornju tvrdnju smjesta prihvatili,
dok bi \textit{konstruktivisti} tražili konkretnu znamenku.
Između ostalog, ovakva razmatranja rezultirala su fundamentalnim uvidom u povezanost programiranja i dokazivanja.
Naime, želimo li dokazati konjunkciju, dovoljno je zasebno dokazati njene konjunkte.
S druge strane, želimo li konstruirati par objekata, dovoljno je zapakirati prvi i drugi objekt u konstruktor para.
Na sličan način, želimo li dokazati implikaciju, dovoljno je pretpostaviti njen antecedent te pomoću njega dokazati konzekvens.
Ako pak želimo konstruirati funkciju, smijemo uzeti njen argument i pomoću njega konstruirati povratnu vrijednost.
Dodatno, nemoguće je dokazati laž, a istina trivijalno vrijedi.
S druge strane, ako induktivni tip nema konstruktore, onda je nenastanjen jer nije moguće definirati vrijednost tog tipa.
Ako pak tip ima barem jedan konstruktor bez argumenata, tada postoje i njegovi stanovnici.
Kroz ove primjere vidimo fenomen \textbf{Curry--Howardove korespondencije}, koju možemo sažeti epigramom:
\begin{displayquote}
  \enquote{Propozicije su tipovi, dokazi su programi.}
\end{displayquote}
\noindent Time se dokazivanje svodi na programiranje. Pogledi na dvije strane ovog novčića mogu se vidjeti u tablici~\ref{tab:curryhoward}.
\begin{table}[!hbt]
  \centering
  \begin{tabular}[!htb]{rl}
    \toprule
    Dokazivanje & Programiranje \\
    \midrule
    propozicija & tip \\
    dokaz & program \\
    laž & prazan tip \\
    istina & nastanjen tip \\    
    konjunkcija & produktni tip \\
    disjunkcija & zbrojni tip \\
    implikacija & funkcijski tip \\
    univerzalna kvantifikacija & zavisni produkt \\
    egzistencijalna kvantifikacija & zavisna suma \\
    \bottomrule
  \end{tabular}
  \caption{Sličnosti dokazivanja i programiranja}\label{tab:curryhoward}
\end{table}

Za bolju ilustraciju, prikazujemo princip matematičke indukcije u Coqu.
Prisjetimo se, za proizvoljni predikat \(P\) na prirodnim brojevima, princip matematičke indukcije glasi:
\[
  P(0) \land \forall n, P(n) \rightarrow P(n + 1) \rightarrow \forall n, P(n).
\]
\noindent Tvrdnju dokazujemo analizom broja \(n\).
Ako je \(n = 0\), tvrdnja slijedi iz \textit{baze} indukcije.
Ako je pak \(n = n^{\prime} + 1\) za neki \(n^{\prime}\), tada rekurzivno konstruiramo dokaz za \(P(n^{\prime})\), a konačna tvrdnja slijedi primjenom \textit{koraka} indukcije na rekurzivno konstruirani dokaz.
\begin{minted}{coq}
Definition nat_ind (P : nat -> Prop)
                   (baza : P 0)
                   (korak : forall n, P n -> P (S n))
  : forall n, P n :=
  fix F (n : nat) : P n :=
    match n with
    | O => baza
    | S n' => korak n' (F n')
    end.
\end{minted}
Za term \texttt{nat\_ind} kažemo da je dokazni term \engl{proof term} za tvrdnju matematičke indukcije.
Princip matematičke indukcije je samo poseban slučaj \textbf{principa indukcije},
koji Coq automatski generira za svaki induktivno definiran tip pri njegovoj definiciji.

\section{Ograničenja tipskog sustava}\label{sec:ogranicenja}
Kao što smo već vidjeli, Coqov tipski sustav je izražajniji od tipskih sustava uobičajenih programskih jezika.
Međutim, kako bi se sačuvala poželjna svojstva algoritma provjere tipova, ipak se tipski sustav mora ograničiti.

\textbf{Uvjet pozitivnosti} odnosi se na definiciju induktivnih i koinduktivnih tipova. 
Ovo ograničenje zabranjuje \textit{negativne} pojave tipa kojeg definiramo u argumentima njegovih konstruktora.
\begin{minted}{coq}
Inductive Lam :=
| LamVar (n : nat)
| LamApp (M N : Lam)
| LamAbs (M : Lam -> Lam).
\end{minted}
\noindent Pokretanje primjera iznad rezultira greškom \texttt{Non strictly positive occurrence of "Lam" in "(Lam -> Lam) -> Lam"} ---
drugim riječima, tip \texttt{Lam} se javlja negativno u konstruktoru \texttt{LamAbs}, odnosno kao argument funkcije koja je parametar konstruktora.
Ovaj uvjet štiti korisnika od inkonzistentnosti, a za točnu definiciju pozitivnosti čitatelja upućujemo na dokumentaciju.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/inductive.html\#well-formed-inductive-definitions}}
Uz uvjet pozitivnosti za induktivne tipove vezan je \textbf{uvjet strukturalne rekurzije}.
Ovim uvjetom osigurava se totalnost rekurzivno definirane funkcije
tako da se argument po kojem je funkcija rekurzivna strukturalno smanjuje u svakom koraku rekurzije 
(funkcija se poziva samo na pravom podtermu originalnog argumenta).

\textbf{Uvjet produktivnosti} odnosi se na definiciju korekurzivnih funkcija, a dualan je uvjetu strukturalne rekurzije.
Ovaj uvjet također štiti korisnika od inkonzistentnosti, a glasi: svaki korekurzivni poziv smije se pojaviti samo kao izravni argument konstruktora koinduktivnog tipa čiji element definiramo (poziv funkcije mora stvoriti pravi nadterm originalnog poziva).\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/coinductive.html\#co-recursive-functions-cofix}}
Zbog tog uvjeta, iduća definicija nije moguća.
\begin{minted}{coq}
Set Primitive Projections.
CoInductive NatStream := {
    nat_hd : nat;
    nat_tl : NatStream;
  }.

CoFixpoint foo : NatStream := foo.
\end{minted}
Greška koju sustav javlja glasi \texttt{Unguarded recursive call in "foo"},
što znači da se korekurzivni poziv \texttt{foo} \textit{ne} javlja kao izravni argument konstruktora.
S druge strane, definicija
\begin{minted}{coq}
CoFixpoint bar : NatStream := {| nat_hd := 0; nat_tl := bar |}.
\end{minted}
\noindent je sasvim legalna.

Posljednje ograničenje koje spominjemo vezano je uz irelevantnost dokaza \engl{proof irrelevance}.
Naime, mnogi teoremi mogu se dokazati na više načina, ali pojedini dokaz (dakle, postupak kojim smo od pretpostavki došli do konkluzije) \textit{nije bitan}.
Matematičarima su bitni samo iskaz teorema i činjenica da se teorem \textit{može dokazati}.
Sam postupak dokazivanja smatra se \enquote{implementacijskim detaljem}.
Upravo zato analiza dokaza ima smisla samo kada se dokazuje, ali ne i kada se programira.
U našoj terminologiji to znači da se \textit{pattern matching} nad dokazima smije provoditi samo kod definiranja terma sorte \texttt{Prop}.
U suprotnom, mogli bismo definirati programe koji ovise o \textit{konkretnom dokazu}, umjesto o iskazanom teoremu.
\textbf{Ograničenje eliminacije propozicije} nastalo je radi omogućavanja ekstrakcije ---
svi termi sorte \texttt{Prop} se \enquote{brišu} prilikom prevođenja iz Coqovog tipskog sustava u tipske sustave niže razine apstrakcije.
Kada ovog ograničenja ne bi bilo, ekstrakcija u jednostavnije jezike naprosto ne bi bila moguća,
jer bi prilikom ekstrakcije bilo nužno zadržati i sve dokaze uz svu kompleksnost njihovih tipova.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
