\chapter{Coq}\label{pog:glavni_dio}
U ovom poglavlju dajemo pogled svisoka na programski sustav Coq.
Prvo ćemo objasniti što je uopće Coq, u kojem je kontekstu nastao, i od kojih komponenti se sastoji.
Zatim ćemo dati kratak pregled programiranja u Coqu, nakon čega ćemo se baviti naprednijim konceptima i spomenuti neka ograničenja.
Za širi opseg gradiva, čitatelja upućujemo na knjige \textit{Coq'Art}~\cite{coqart}, \textit{Software Foundations}~\cite{sf-lf, sf-plf, sf-vfa} i \textit{Certified Programming with Dependent Types}~\cite{cpdt} te na službenu dokumentaciju~\cite{coqrefman}.

\section{Što je Coq?}\label{sec:osnovno-o-coqu}
Alat za dokazivanje Coq\footnote{\url{https://coq.inria.fr/}}, punog naziva \textit{The Coq Proof Assistant},
programski je sustav pomoću kojeg korisnici mogu dokazivati matematičke tvrdnje. \misao{ne sluzi samo tome, moze biti i opceniti funkcijski programski jezik, moze sluziti za programiranje sa zavisnim tipovima}
Alat se temelji na \(\lambda\)-računu i teoriji tipova, a prva je inačica implementirana godine 1984.~\cite{coqrefman}
Ovaj rad koristi inačicu \(8.18\) iz rujna godine 2023.

Program Coq može se pokrenuti u interaktivnom ili u skupnom načinu rada.
Interaktivni način rada pokreće se naredbom \texttt{coqtop}, a korisniku omogućuje rad u ljusci sličnoj \texttt{bash} i \texttt{python} ljuskama.
Interaktivna ljuska (također poznata pod imenom \textit{toplevel}) služi unosu definicija i iskazivanju lema.
Skupni način rada pokreće se naredbom \texttt{coqc}, a korisniku omogućuje semantičku provjeru i prevođenje izvornih datoteka u jednostavnije formate.
Kod formaliziranja i dokazivanja, korisnik će najčešće koristiti interaktivni način rada, po mogućnosti kroz neku od dostupnih razvojnih okolina.
\footnote{Autor rada koristio je paket \textit{Proof General} za uređivač teksta \textit{Emacs}. Druge često korištene okoline su \textit{VsCoq} i \textit{CoqIDE}.}

\misao{spomenuti proof mode? spomenuti workflow dokazivanja? ima jedna zgodna slika u QED at Large}
\misao{treba naglasiti da je Coq \textit{interaktivni} dokazivač teorema}

Kao programski jezik, Coq se sastoji od više podjezika različitih namjena, od kojih spominjemo \textit{Vernacular}, \textit{Gallinu} i \textit{Ltac}.
\begin{description}
\item[Vernacular] \misao{\textit{vernacular} znači ``govorni jezik''} je jezik naredbi kojima korisnik komunicira sa sustavom (i u interaktivnom i u skupnom načinu rada);
  svaka Coq skripta (datoteka s nastavkom \texttt{.v}) je niz naredbi.
  Neke od najčešće korištenih naredbi su \texttt{Check}, \texttt{Definition}, \texttt{Inductive}, \texttt{Fixpoint} i \texttt{Lemma}.
  Pomoću naredbi za tvrdnje, kao što je \texttt{Lemma}, Coq prelazi iz \textit{toplevela}\misao{treba bolji prevod} u način dokazivanja~\engl{proof mode}.
\item[Gallina] je Coqov strogo statički tipiziran specifikacijski jezik.
  Kako se glavnina programiranja u Coqu svodi upravo na programiranje u Gallini, posvećujemo joj idući odjeljak.
\item[Ltac] je Coqov netipiziran jezik za definiciju i korištenje taktika.
  Taktike su pomoćne naredbe kojima se u načinu dokazivanja konstruira dokaz.
  Može se reći da je Ltac jezik za metaprogramiranje Galline.
  Primjeri taktika su \texttt{intros}, \texttt{destruct}, \texttt{apply} i \texttt{rewrite}.
\end{description} % https://coq.discourse.group/t/what-is-the-difference-between-gallina-and-ltac/1184 
\noindent Pogledajmo ilustrativan primjer.
\begin{minted}{coq}
  Lemma example_lemma : 1 + 1 = 2.
  Proof.
    cbn. reflexivity.
  Qed.
\end{minted}
\noindent Ključne riječi \texttt{Lemma}, \texttt{Proof} i \texttt{Qed} dio su Vernaculara,
izraz \texttt{example\_lemma : 1 + 1 = 2} dio je Galline,
a pomoćne naredbe \texttt{cbn} i \texttt{reflexivity} dio su Ltaca.

Jezgra programskog sustava Coq je algoritam za provjeru tipova \engl{type checking} implementiran u OCamlu ---
svaka tvrdnja koja se dokazuje izrečena je pomoću tipova.
Ostatak sustava u načelu služi za knjigovodstvo i poboljšanje korisničkog iskustva.
Nužno je da jezgra sustava bude relativno mala kako bismo se mogli uvjeriti u njenu točnost.
U suprotnom, možemo li biti sigurni da su naše dokazane tvrdnje doista istinite?
\misao{kažem istinite, ali u stvari mislim dokazive, no to je nespretno za napisati i diskusija oko toga je preopćenita}

Prve inačice Coqa implementirale su račun konstrukcija, no kasnije je dodana podrška za induktivno i koinduktivno definirane tipove~\cite{cic, coinductive}.
Danas se može reći da Coq implementira polimorfni kumulativni račun induktivnih konstrukcija~\cite{coqcoqcorrect}.
\misao{mogu spomenuti i preteče računa konstrukcija i jezike koji ih implementiraju, npr.~ Lisp je implementacija \(\lambda\)-računa}
Coq se, osim kao dokazivač teorema, može koristiti i za programiranje sa zavisnim tipovima.
U toj sferi konkuriraju jezici Agda\footnote{\url{https://wiki.portal.chalmers.se/agda/}}, Idris\footnote{\url{https://www.idris-lang.org/}} i Lean\footnote{\url{https://lean-lang.org/}}. Coq se između njih istiće po usmjerenosti prema dokazivanju, posebno po korištenju taktika (jezik Ltac) i nepredikativnoj sorti \texttt{Prop} (o kojoj će kasnije biti riječi).
Još jedna prednost Coqa je mehanizam \textit{ekstrakcije} pomoću kojeg korisnik može proizvoljnu funkciju\footnote{Za koju je dokazao točnost, štogod to značilo.} prevesti u jezik niže razine apstrakcije.\footnote{Trenutno su podržani Haskell, OCaml i Scheme.}
Mehanizam ekstrakcije nije dokazano točan, no poželjno je da funkcije zadržavaju točnost i nakon ekstrakcije pa se radi na verifikaciji ekstrakcije~\cite{coqcoqcorrect}.

\section{Programiranje u Coqu}\label{sec:programiranje-u-gallini}
Gallina je funkcijski programski jezik, što znači da su funkcije prvoklasni objekti ---
funkcije mogu biti argumenti i povratne vrijednosti drugih funkcija.
Dodatno, varijable su nepromjenjive \engl{immutable} te se iteracija ostvaruje rekurzijom.
Za uvod u funkcijsko programiranje, čitatelja upućujemo na knjigu \textit{Programming in Haskell}~\cite{Hutton_2016}.
Primjeri koje ćemo vidjeti u ostatku ovog odjeljka dijelom se osljanjanju na tipove i funkcije definirane u Coqovoj standardnoj knjižnici.\footnote{\url{https://coq.inria.fr/library/}}

Gallina je strogo statički tipiziran jezik, što znači da se svakom termu prilikom prevođenja dodjeljuje tip\footnote{Tipovi su kolekcije srodnih objekata.}.
Naredbom \texttt{Check} možemo provjeriti tip nekog terma ili doznati da se termu ne može dodjeliti tip.
Dalje u radu pod ``term'' mislimo na dobro formirane terme, odnosno na one terme kojima se može dodijeliti tip.
Kažemo da je term \textit{stanovnik} tipa koji mu je dodijeljen.
Za tip kažemo da je \textit{nastanjen}, odnosno \textit{nenastanjen}, ako postoji, odnosno ne postoji, stanovnik tog tipa.
Kako su u Coqu i tipovi termi, radi razumljivosti i zvučnosti umjesto ``tip tipa'' kažemo ``sorta tipa''.

Kao i u ostalim jezicima, kod programiranja u Coqu korisnik se oslanja na dostupne primitivne izraze,
od kojih su najvažniji:
\begin{itemize}
\item \texttt{forall}, pomoću kojeg se konstruiraju funkcijski tipovi i zavisni produkti;
\item \texttt{match}, pomoću kojeg se provodi \textit{pattern matching};
\item \texttt{fun}, pomoću kojeg se definiraju funkcije;
\item \texttt{fix}, pomoću kojeg se definiraju rekurzivne funkcije i
\item \texttt{cofix}, pomoću kojeg se definiraju korekurzivne funkcije.
\end{itemize}

Jedna od osnovnih naredbi za stvaranje novih terma je naredba \texttt{Definition}.
\begin{minted}{coq}
Definition negb (b : bool) : bool :=
match b with
| false => true
| true => false
end.
\end{minted}
\noindent U gornjem kodu definirana je funkcija \texttt{negb} čiji se argument \texttt{b} tipa \texttt{bool} destrukturira te se vraća njegova negacija, također tipa \texttt{bool}.
Važno je napomenuti da svaki \texttt{match} izraz mora imati po jednu granu za svaki konstruktor tipa.\footnote{U tandemu s uvjetom strukturalne rekurzije, ovime je osigurana totalnost svake funkcije.}
U ovom su primjeru konstante \texttt{false} i \texttt{true} jedini konstruktori tipa \textit{bool}.
Funkcija \texttt{negb} je tipa \texttt{bool\(\rightarrow\)bool}.
\begin{minted}{coq}
Definition mult_zero_r : Prop := forall (n : nat), n * 0 = 0.
\end{minted}
Ovdje je definirana propozicija (tip) imena \texttt{mult\_zero\_r} kao univerzalno kvantificirana tvrdnja po prirodnim brojevima.

Naredbom \texttt{\textbf{Inductive}} definira se \textit{induktivni} tip te se automatski za njega generiraju principi \textit{indukcije} i \textit{rekuzrije}.
\begin{minted}{coq}
Inductive nat : Set :=
| O : nat
| S : nat -> nat.
\end{minted}
Ovim kodom definirali smo tri terma:
\begin{itemize}
\item \texttt{nat} (tip prirodnih brojeva) je term sorte \texttt{Set},
\item \texttt{O} (broj nula) je term tipa \texttt{nat} i
\item \texttt{S} (funkcija sljedbenika) je term tipa \texttt{nat\(\rightarrow\)nat}.
\end{itemize}
\noindent Za term \texttt{nat} kažemo da je konstruktor tipa \engl{type constructor}, a za terme \texttt{O} i \texttt{S} kažemo da su konstruktori objekata \engl{object constructors}.

Rekurzija nad induktivnim tipovima može se ostvariti naredbom \texttt{Fixpoint}, koja u pozadini koristi izraz \texttt{fix}.
\begin{minted}{coq}
Fixpoint plus (n m : nat) {struct n} : nat :=
match n with
| O => m
| S n' => S (plus n' m)
end.
\end{minted}
U ovom primjeru definirana je funkcija \texttt{plus} koja prima dva argumenta tipa \texttt{nat}.
Funkcija je rekurzivna po prvom argumentu što je vidljivo oznakom \texttt{\{struct n\}}.
Napominjemo da su induktivni tipovi dobro utemeljeni, to jest svaki term induktivnog tipa je konačan.

Osim induktivnih, u Coqu postoje i koinduktivni tipovi, koji nisu dobro utemeljeni,
zbog čega za njih nije moguće definirati principe indukcije i rekurzije.
Umjesto rekurzije, koinduktivni tipovi koriste se u korekurzivnim funkcijama.
Standardan primjer koinduktivnog tipa je beskonačna lista.
\begin{minted}{coq}
Set Primitive Projections.
CoInductive Stream (A : Type) := {
      hd : A;
      tl : Stream A;
    }.
\end{minted}
Ovime smo definirali familiju tipova \texttt{Stream} indeksiranu tipskom varijablom \texttt{A}.
Svaki \texttt{Stream} ima glavu i rep koji je također \texttt{Stream}.

Stanovnici koinduktivnih tipova konstruiraju se korekurzivnim funkcijama naredbom \texttt{CoFixpoint}, koja u pozadini koristi \texttt{cofix}.
\begin{minted}{coq}
CoFixpoint from (n : nat) : Stream nat := Cons _ n (from (n + 1)).
\end{minted}
Ovime je definirana funkcija \texttt{from} koja za ulazni argument \texttt{n} vraća niz prirodnih brojeva od \(n\) na dalje.

Razlika induktivnih i koinduktivnih tipova može se izreći epigramom:\\
\[
  \textrm{``Induktivni tipovi su domene rekurzivnih funkcija, a koinduktivni tipovi su kodomene korekurzivnih funkcija''.}
\]
\noindent Time se želi reći da se termi induktivnih tipova destrukturiraju u rekurzivnim funkcijama,
dok se termi koinduktivnih tipova konstruiraju u korekurzivnim funkcijama.

\misao{Barendregtova kocka, term koji ovisi o termu, term koji ovisi o tipu, tip koji ovisi o termu, tip koji ovisi o tipu}

\section{Hijerarhija tipova}\label{sec:kumul-hijer-tipova}
U usporedbi s tradicionalnim programskim jezicima, Coqov tipski sustav je ekspresivniji jer dopušta tipove koji mogu ovisiti o termima.
Takvi tipovi se u Coqu konstruiraju \texttt{forall} izrazom.
Primjer jednog takvog tipa je ``lista duljine \(n\)'', gdje je \(n\) neki prirodan broj, a čiji su stanovnici \(n\)-torke.
Općeniti tip tada glasi ``za svaki \(n\), lista duljine \(n\)'' --- on ovisi o stanovniku drugog tipa (u ovom slučaju, tipa \texttt{nat}).

Spomenuli smo da su i tipovi termi te im se može dodijeliti sorta.
Postoji li najveći tip, odnosno postoji li tip \texttt{Type} čiji su stanovnici svi dobro formirani termi?
Prisjetimo se, svaki term ima svoj tip.
Kada bi takav \texttt{Type} postojao, tada bi vrijedilo \verb|Type:Type|, što može dovesti do paradoksa lašca\footnote{Ova rečenica je lažna. U teoriji skupova to je Russellov paradoks, u teoriji tipova to je Girardov paradoks}.
Takav dokazivač teorema bio bi inkonzistentan te bismo njime mogli dokazati kontradikciju, čime dokazivač efektivno gubi svoju svrhu.
Umjesto jedne ``velike'' sorte \texttt{Type}, u Coqu postoji niz monotono rastućih sorti \coqtype{n} za sve prirodne brojeve \(n\),
takav da vrijedi \(\coqtype{n} : \coqtype{m}\) kad god vrijedi \(n < m\).
Ilustracija ove \textbf{kumulativne hijerarhije tipova} prikazana je na slici~\ref{fig:kum-hijer-tip}.
Dvije najvažnije sorte u Coqu su sorta \texttt{Set} i sorta \texttt{Prop}.

\begin{figure}[htb]
  \centering
  \begin{forest}
    for tree={l sep+=5mm}
    [\vdots
    [\coqtype{m+1}
    [\ldots]
    [\texttt{bool\(\rightarrow\)\coqtype{m}}]
    [\coqtype{m} [\ldots][\vdots
    [\coqtype{1}
    [\coqset [\texttt{bool}\\ \texttt{nat}\\ \vdots, align=center, base=top] [\texttt{list nat}\\ \texttt{prod nat bool}\\ \texttt{nat\(\rightarrow\)nat}\\ \vdots{}, align=center, base=top] [\ldots]]
    [\texttt{bool}\(\rightarrow\)\coqset]
    [\ldots]
    [\coqprop [\texttt{True}\\ \texttt{1+1=2}\\ \vdots, align=center, base=top] [\texttt{False}\\ \texttt{\(\forall\)b,negb b=b}\\ \vdots, align=center, base=top] [\ldots]]
    [\texttt{nat}\(\rightarrow\)\coqprop]
    [\ldots]
    ]
    ] [\ldots]
    ] [\coqtype{m} \(\rightarrow\) \coqprop] [\ldots]]]
  \end{forest}
  \caption{Kumulativna hijerarhija tipova}\label{fig:kum-hijer-tip}
\end{figure}

Naziv \coqset{} sinonim je za sortu \coqtype{0}, a njeni stanovnici su \textbf{mali tipovi}.
\misao{NB: Tu je prije pisalo da su stanovnici od \texttt{Set} programi, no to nije tako. Stavovnici od \texttt{Set} su mali tipovi (ne znam kako ih drugačije nazvati), a tek onda su stanovnici malih tipova programi.} 
Primjerice, tipovi \texttt{nat} i \texttt{bool} su mali tipovi.
Dodatno, funkcije koje primaju i vraćaju male tipove su također mali tipovi.
Tada su i produkti, sume, liste i stabla malih tipova također mali tipovi.
Intuitivno se može reći da su mali oni tipovi s čijim se stanovnicima može efektivno računati.
Stanovnike malih tipova nazivamo \textbf{programima}.

Stanovnici sorte \texttt{Prop} su \textbf{propozicije}.
Za razliku od programa, sa propozicijama ne možemo efektivno računati, već ih moramo dokazivati.
Stanovnici propozicija su njihovi \textbf{dokazi}.

Za dokazivače teorema, poželjna je mogućnost definicije predikata (propozicija) nad proizvoljnim tipovima.
Zbog toga u Coqu prilikom definicije terma sorte \texttt{Prop} možemo raditi kvantifikaciju po proizvoljno velikim tipovima
(što uključuje i sortu \texttt{Prop}).
\begin{minted}{coq}
Inductive isNat : Set -> Prop :=
| IsNat : isNat nat.
\end{minted}
\noindent Tako je ovdje \texttt{isNat} predikat nad sortom \coqset{}, a u primjeru ispod \texttt{not} je predikat nad sortom \coqprop{}.
\begin{minted}{coq}
Definition not (P : Prop) := P -> False.
\end{minted}
\noindent Ovaj stil kvantifikacije omogućuje nam definiciju proizvoljnih propozicija i propozicijskih veznika.
Kažemo da je sorta \coqprop{} \textbf{nepredikativna}.
S druge strane, sorta \coqset{} je \textbf{predikativna}, to jest \textit{ne dopušta} kvantifikaciju po proizvoljno velikim tipovima.
Na praktičnoj strani, predikativnost ograničava korisnika da prilikom definicije programa smije koristiti samo druge programe.


\section{Propozicije i tipovi, dokazi i termi}\label{sec:propozicije-i-tipovi}
U decimalnom zapisu broja \(\pi\), barem jedna znamenka pojavljuje se beskonačno mnogo puta.
Doista, kada bi se svaka znamenka javljala samo konačno mnogo puta, broj \(\pi\) bio bi racionalan.
Međutim, nije jasno \textit{koja} znamenka ima to svojstvo.
Da bismo odgovorili na to pitanje, morali bismo prebrojiti \textit{sve} broja \(\pi\),
što nije moguće u konačno mnogo koraka.

Sličnim pitanjima bavili su se logičari dvadesetog stoljeća. \textit{Klasični} logičari bi gornju tvrdnju smjesta prihvatili,
dok bi \textit{konstruktivisti} tražili konkretnu znamenku.
Između ostalog, ovakva razmatranja rezultirala su fundamentalnim uvidom u povezanost programiranja i dokazivanja.
Naime, želimo li dokazati konjunkciju, dovoljno je zasebno dokazati njene konjunkte.
S druge strane, želimo li konstruirati par objekata, dovoljno je zapakirati prvi i drugi objekt u konstruktor para.
Na sličan način, želimo li dokazati implikaciju, dovoljno je pretpostaviti njen antecedent te pomoću njega dokazati konzekvens.
Ako pak želimo konstruirati funkciju, smijemo uzeti jedan argument i pomoću njega konstruirati povratnu vrijednost.
Dodatno, nemoguće je dokazati laž, a istina trivijalno vrijedi.
S druge strane, ako tip nema konstruktore, nije moguće definirati vrijednost tog tipa.
Ako pak tip ima barem jedan konstruktor, tada postoje i njegovi stanovnici.
Kroz ove primjere vidimo fenomen \textbf{Curry--Howardove korespondencije}, koju možemo sažeti epigramom:
\[
  \textrm{``Propozicije su tipovi, dokazi su programi.''}
\]
\\ Time se dokazivanje svodi na programiranje. Pogledi na dvije strane ovog novčića mogu se vidjeti u tablici~\ref{tab:curryhoward}.
\begin{table}[!hbt]
  \centering
  \begin{tabular}[!htb]{rl}
    \toprule \\
    Dokazivanje & Programiranje \\
    \midrule \\
    propozicija & tip \\
    dokaz & program \\
    laž & prazan tip \\
    istina & nastanjen tip \\    
    konjunkcija & produktni tip \\
    disjunkcija & zbrojni tip \\
    implikacija & funkcijski tip \\
    univerzalna kvantifikacija & zavisni produkt \\
    egzistencijalna kvantifikacija & zavisni koprodukt \\
    \bottomrule
  \end{tabular}
  \caption{Sličnosti dokazivanja i programiranja}\label{tab:curryhoward}
\end{table}

Za bolju ilustraciju, prikazujemo princip matematičke indukcije u Coqu.
Prisjetimo se, za proizvoljni predikat \(P\) nad prirodnim brojevima, princip matematičke indukcije glasi:
\[
  P(0) \land (\forall n, P(n) \rightarrow P(n + 1)) \rightarrow \forall n, P(n).
\]
\noindent Tvrdnju dokazujemo analizom broja \(n\).
Ako je \(n = 0\), tvrdnja slijedi iz \textit{baze} indukcije.
Ako pak je \(n = n^{\prime} + 1\) za neki \(n^{\prime}\), tada rekurzivno konstruiramo dokaz za \(P(n^{\prime})\), a konačna tvrdnja slijedi primjenom \textit{koraka} indukcije na rekurzivno konstruirani dokaz.
\begin{minted}{coq}
Definition nat_ind (P : nat -> Prop) (baza : P 0) (korak : forall n, P n -> P (S n))
  : forall n, P n :=
  fix F (n : nat) : P n :=
    match n with
    | O => baza
    | S n' => korak n' (F n')
    end.
\end{minted}
Za term \texttt{nat\_ind} kažemo da je dokazni objekt \engl{proof object} za tvrdnju matematičke indukcije.
Princip matematičke indukcije je samo poseban slučaj \textbf{principa indukcije}, kojeg Coq automatski generira za svaki induktivno definiran tip.

\section{Ograničenja tipskog sustava}\label{sec:ogranicenja}
Kao što smo već vidjeli, Coqov tipski sustav je ekspresivniji od tipskih sustava tradicionalnih programskih jezika.
Međutim, kako bi se sačuvala poželjna svojstva algoritma provjere tipova, ipak se tipski sustav mora ograničiti.

\textbf{Uvjet pozivitnosti} odnosi se na definiciju induktivnih i koinduktivnih tipova.
\misao{NB: uvjet pozitivnosti mora vrijediti i u pozitivinim i u negativnim koinduktivnim tipovima.}
Ovo ograničenje zabranjuje \textit{negativne} pojave tipa kojeg definiramo u argumentima njegovih konstruktora.
\begin{minted}{coq}
Inductive Lam :=
| LamVar (n : nat)
| LamApp (M N : Lam)
| LamAbs (M : Lam -> Lam).
\end{minted}
\noindent Pokretanje primjera iznad rezultira greškom \texttt{Non strictly positive occurrence of "Lam" in "(Lam -> Lam) -> Lam"} ---
drugim riječima, tip \texttt{Lam} se javlja negativno u konstruktoru \texttt{LamAbs}, odnosno kao argument funkcije koja je parametar konstruktora.
Ovaj uvjet štiti korisnika od inkonzistentnosti, a za točnu definiciju pozitivnosti čitatelja upućujemo na dokumentaciju.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/inductive.html\#well-formed-inductive-definitions}}
Uz uvjet pozitivnosti za induktivne tipove vezan je \textbf{uvjet strukturalne rekurzije}.
Ovim uvjetom osigurava se totalnost rekurzivno definirane funkcije
tako da se argument po kojem je funkcija rekurzivna strukturalno smanjuje u svakom koraku rekurzije.

\textbf{Uvjet produktivnosti} odnosi se na definiciju korekurzivnih funkcija, a dualan je uvjetu strukturalne rekurzije.
Ovaj uvjet također štiti korisnika od inkonzistentnosti, a glasi: svaki korekurzivni poziv smije se javljati točno kao izravan argument konstruktora koinduktivnog tipa čiji element definiramo.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/coinductive.html\#co-recursive-functions-cofix}}
Zbog tog uvjeta, iduća definicija nije moguća.
\begin{minted}{coq}
Set Primitive Projections.
CoInductive NatStream := {
    nat_hd : nat;
    nat_tl : NatStream;
  }.

CoFixpoint foo : NatStream := foo.
\end{minted}
Greška koju sustav javlja glasi \texttt{Unguarded recursive call in "foo"},
što znači da se korekurzivni poziv \texttt{foo} \textit{ne} javlja kao izravni argument konstruktora.
S druge strane, definicija
\begin{minted}{coq}
CoFixpoint bar : NatStream := {| nat_hd := 0; nat_tl := bar |}.
\end{minted}
\noindent je sasvim legalna.
\misao{Tu se baš i ne vidi zašto se \texttt{bar} javlja kao izravan argument konstruktora jer koristimo negativni koinduktivni tip. Ispod haube je to sve zamotano u neki \texttt{Build\_NatStream}.}

\misao{Bili smo spomenuli četiri ograničenja na sastanku.
  Uvjet strukturalne rekurzije i uvjet produktivnosti su na neki način dualni.
  Treće ograničenje bio je uvjet pozitivnosti.
  Čovjek očekuje da onda postoji nešto dualno uvjetu pozitivnosti za koinduktivne tipove.
  Nije li to opet uvjet pozitivnosti?
}

\misao{Ipak neću spomenuti razlike između pozitivinih i negativnih koinduktivnih tipova.
  Mislim da je to izvan dosega ovog rada.}

Posljednje ograničenje koje spominjemo vezano je uz irelevantnost dokaza \engl{proof irrelevance}.
Naime, mnogi teoremi mogu se dokazati na više načina, ali svaki pojedini dokaz (dakle, postupak kojim smo od pretpostavka došli do konkluzije) \textit{nije bitan}.
Matematičarima su bitni samo iskaz teorema i činjenica da se teorem \textit{može dokazati}.
Sam postupak dokazivanja smatra se ``implementacijskim detaljom''.
Upravo zato analiza dokaza ima smisla samo kada se dokazuje, ali ne i kada se programira.
U našoj terminologiji to znači da se \textit{pattern matching} nad dokazima smije provoditi samo kod definiranja terma sorte \texttt{Prop}.
U suprotnom, mogli bismo definirati programe koji ovise o \textit{konkretnom dokazu}, umjesto o iskazanom teoremu.
\textbf{Ograničenje eliminacije propozicije} nastalo je radi ekstrakcije ---
svi termi sorte \texttt{Prop} se ``brišu'' prilikom prevođenja iz Coqovog tipskog sustava u tipske sustave niže razine apstrakcije.
Kada ovog ograničenja nebi bilo, ekstrakcija u jednostavnije jezike naprosto nebi bila moguća.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
