\chapter{Coq}\label{pog:glavni_dio}
U ovom poglavlju dajemo pogled svisoka na programski sustav Coq.
Prvo ćemo objasniti što je uopće Coq, u kojem je kontekstu nastao, i od kojih komponenti se sastoji.
Zatim ćemo dati kratak pregled programiranja u Coqu, nakon čega ćemo se baviti naprednijim konceptima i spomenuti neka ograničenja.
Za širi opseg gradiva, čitatelja upućujemo na knjige \textit{Coq'Art}~\cite{coqart}, \textit{Software Foundations}~\cite{sf-lf, sf-plf, sf-vfa} i \textit{Certified Programming with Dependent Types}~\cite{cpdt} te na službenu dokumentaciju~\cite{coqrefman}.

\section{Što je Coq?}\label{sec:osnovno-o-coqu}
Alat za dokazivanje Coq\footnote{\url{https://coq.inria.fr/}}, punog naziva \textit{The Coq Proof Assistant},
programski je sustav pomoću kojeg korisnici mogu dokazivati matematičke tvrdnje. \misao{ne sluzi samo tome, moze biti i opceniti funkcijski programski jezik, moze sluziti za programiranje sa zavisnim tipovima}
Alat se temelji na \(\lambda\)-računu i teoriji tipova, a prva je inačica implementirana godine 1984.~\cite{coqrefman}
Ovaj rad koristi inačicu \(8.18\) iz rujna godine 2023.

Program Coq može se pokrenuti u interaktivnom ili u skupnom načinu rada.
Interaktivni način rada pokreće se naredbom \texttt{coqtop}, a korisniku omogućuje rad u ljusci sličnoj \texttt{bash} i \texttt{python} ljuskama.
Interaktivna ljuska (također poznata pod imenom \textit{toplevel}) služi unosu definicija i iskazivanju lema.
Skupni način rada pokreće se naredbom \texttt{coqc}, a korisniku omogućuje semantičku provjeru i prevođenje izvornih datoteka u jednostavnije formate.
Kod formaliziranja i dokazivanja, korisnik će najčešće koristiti interaktivni način rada, po mogućnosti kroz neku od dostupnih razvojnih okolina.
\footnote{Autor rada koristio je paket \textit{Proof General} za uređivač teksta \textit{Emacs}. Druge često korištene okoline su \textit{VsCoq} i \textit{CoqIDE}.}

\misao{tu negdje treba spomenuti proof mode, koji je zaseban od toplevela}

Kao programski jezik, Coq se sastoji od više podjezika različitih namjena, od kojih spominjemo \textit{Vernacular}, \textit{Gallinu} i \textit{Ltac}.
\begin{description}
\item[Vernacular] \misao{\textit{vernacular} znači ``govorni jezik''} je jezik naredbi kojima korisnik komunicira sa sustavom (i u interaktivnom i u skupnom načinu rada);
  svaka Coq skripta (datoteka s nastavkom \texttt{.v}) je niz naredbi.
  Neke od najčešće korištenih naredbi su \texttt{Check}, \texttt{Definition}, \texttt{Inductive}, \texttt{Fixpoint} i \texttt{Lemma}.
  Pomoću naredbi za tvrdnje, kao što je \texttt{Lemma}, Coq prelazi iz \textit{toplevela}\misao{treba bolji prevod} u način dokazivanja~\engl{proof mode}.
\item[Gallina] je Coqov strogo statički tipiziran specifikacijski jezik.
  Kako se glavnina programiranja u Coqu svodi upravo na programiranje u Gallini, posvećujemo joj idući odjeljak.
\item[Ltac] je Coqov netipiziran jezik za definiciju i korištenje taktika.
  Taktike su pomoćne naredbe kojima se u načinu dokazivanja konstruira dokaz.
  Može se reći da je Ltac jezik za metaprogramiranje Galline.
  Primjeri taktika su \texttt{intros}, \texttt{destruct}, \texttt{apply} i \texttt{rewrite}.
\end{description} % https://coq.discourse.group/t/what-is-the-difference-between-gallina-and-ltac/1184 
\noindent Pogledajmo ilustrativan primjer.
\begin{minted}{coq}
  Lemma example_lemma : 1 + 1 = 2.
  Proof.
    cbn. reflexivity.
  Qed.
\end{minted}
\noindent Ključne riječi \texttt{Lemma}, \texttt{Proof} i \texttt{Qed} dio su Vernaculara,
izraz \texttt{example\_lemma : 1 + 1 = 2} dio je Galline,
a pomoćne naredbe \texttt{cbn} i \texttt{reflexivity} dio su Ltaca.

Jezgra programskog sustava Coq je algoritam za provjeru tipova \engl{type checking} implementiran u OCamlu ---
svaka tvrdnja koja se dokazuje izrečena je pomoću tipova.
Ostatak sustava u načelu služi za knjigovodstvo i poboljšanje korisničkog iskustva.
Nužno je da jezgra sustava bude relativno mala kako bismo se mogli uvjeriti u njenu točnost.
U suprotnom, možemo li biti sigurni da su naše dokazane tvrdnje doista istinite?
\misao{kažem istinite, ali u stvari mislim dokazive, no to je nespretno za napisati i diskusija oko toga je preopćenita}

Prve inačice Coqa implementirale su račun konstrukcija, no kasnije je dodana podrška za induktivno i koinduktivno definirane tipove~\cite{cic, coinductive}.
Danas se može reći da Coq implementira polimorfni kumulativni račun induktivnih konstrukcija~\cite{coqcoqcorrect}.
\misao{mogu spomenuti i preteče računa konstrukcija i jezike koji ih implementiraju, npr.~ Lisp je implementacija \(\lambda\)-računa}
Coq se, osim kao dokazivač teorema, može koristiti i za programiranje sa zavisnim tipovima.
U toj sferi konkuriraju jezici Agda\footnote{\url{https://wiki.portal.chalmers.se/agda/}}, Idris\footnote{\url{https://www.idris-lang.org/}} i Lean\footnote{\url{https://lean-lang.org/}}. Coq se između njih istiće po usmjerenosti prema dokazivanju, posebno po korištenju taktika (jezik Ltac) i nepredikativnoj sorti \texttt{Prop} (o kojoj će kasnije biti riječi).

\section{Programiranje u Gallini}\label{sec:programiranje-u-gallini}
Gallina je funkcijski programski jezik ugrađen u Coq, što znači da su funkcije prvoklasni objekti ---
funkcije mogu biti argumenti i povratne vrijednosti drugih funkcija.
Dodatno, varijable su nepromjenjive \engl{immutable} te se iteracija ostvaruje rekurzijom.
Za uvod u funkcijsko programiranje, čitatelja upućujemo na knjigu \textit{Programming in Haskell}~\cite{Hutton_2016}.
Gallina je strogo statički tipiziran jezik, što znači da se svakom termu prilikom prevođenja dodjeljuje tip.
U općenitom smislu, tip je kolekcija sličnih objekata. 
Tip nekog terma možemo provjeriti (Vernacular) naredbom \texttt{Check}.
\begin{description}
\item[Funkcijsko programiranje] neki jednostavni primjer
\item[Definiranje funkcija] \texttt{Definition}, \texttt{Fixpoint}, \texttt{CoFixpoint}
\item[Definiranje tipova] \texttt{Inductive}, \texttt{CoInductive}
\item[Ekstrakcija] OCaml, Haskell, spomenuti da se radi na verificiranoj ekstrakciji
\end{description}
\misao{kod Fixpoint, spomenuti da je Gallina odlučiv jezik, odnosno da je za svaka Gallinina funkcija odlučiva}
\section{Kumulativna hijerarhija tipova}\label{sec:kumul-hijer-tipova}
Ukratko objasniti. Lijepa skica koja prikazuje gdje su \texttt{nat}, \texttt{nat -> nat}, \texttt{nat -> Set}, \texttt{Prop -> Prop}, i njima srodni. Razlika između \texttt{Set} i \texttt{Prop}.

\begin{figure}[hbt]
  \centering
  \begin{tikzpicture}[sibling distance=3cm]
    \node {\vdots{}}
    child {
      node {\(\mathtt{Type_{m+1}}\)}
      child {
        node {\(\mathtt{Type_{m}}\)}
        child {
          node {\vdots{}}
          child {
            node {\(\mathtt{Type_{3}}\)}
            child {
              node {\(\mathtt{Type_{2}}\)}
              child {
                node {\(\mathtt{Type_{1}}\)}
                child {
                  node {\(\mathtt{Set}\)}
                  child {
                    node {\(\mathtt{nat}\)}
                  }
                  child {
                    node {\(\mathtt{nat \rightarrow nat}\)}
                  }
                  child {
                    node {\(\mathtt{bool}\)}
                  }
                }
                child {
                  node {\(\mathtt{Prop}\)}
                }
                child {
                  node {\(\mathtt{Prop \rightarrow Prop}\)}
                }
                child {
                  node {\(\mathtt{Prop \rightarrow Prop \rightarrow Prop}\)}
                }
              }
            }
          }
        }
      }
      child {
        node {\(\mathtt{Type_{3} \rightarrow Type_{m}}\)}
      }
      child {
        node {\(\mathtt{nat \rightarrow Type_{m}}\)}
      }
    };
  \end{tikzpicture}
  \caption{Kumulativna hijerarhija tipova}
  \label{fig:kumhijertip}
\end{figure}
\misao{Kad malo bolje razmislim, sve funkcije u Coqu koje primaju nešto tipa \texttt{Type} u stvari implicitno primaju dodatni parametar; razinu svemira}

\section{Propozicije i tipovi, dokazi i programi}\label{sec:propozicije-i-tipovi}
Ukratko objasniti što je to Curry--Howard, možda najlakše pomoću BHK interpretacije.

Primjeri dokaznih terma, recimo ručno napisan dokazni term za komutiranje univerzalnih kvantifikacija, pa neki jednostavni induktivni dokaz.

Principi indukcije kao rekurzivne funkcije.
\begin{table}[hbt]
  \centering
  \begin{tabular}[hbt]{rlrl}
    \toprule \\
    Logika & Program & Logički term & Programski term \\
    \midrule \\
    konjunkcija & produktni tip  & \texttt{and} & \texttt{prod} \\
    disjunkcija & zbrojni tip & \texttt{or} & \texttt{sum} \\
    implikacija & funkcijski tip & \texttt{->} & \texttt{->} \\
    univerzalna kvantifikacija & zavisni produkt & \texttt{forall x, P x} & \texttt{forall x, P x} \\
    egzistencijalna kvantifikacija & zavisni koprodukt & \texttt{ex} & \texttt{sigT} \\
    istina & jedinični tip & \texttt{True} & \texttt{unit} \\
    laž & prazni tip & \texttt{False} & \texttt{Empty\_set} \\
    modus ponens & poziv funkcije &  &  \\
    teorem & tip & & \\
    dokaz & term & & \\
    pretpostavka & varijabla & & \\
    dokazivanje & programiranje & & \\
    dokazivost & nastanjenost tipa & & \\
    \bottomrule
  \end{tabular}
  \caption{Korespondencija logike i programiranja}\label{tab:curryhoward}
\end{table}
\misao{Zavisni produkt se zove produkt jer je univerzalna kvantifikacija u načelu beskonačna konjunkcija.}
\misao{Zavisni koprodukt se zove koprodukt jer ??? Ako gledamo obične produkte, obični koprodukt je onda suma.}

\section{Ograničenja u programiranju i dokazivanju}\label{sec:ogranicenja}
Tu prvenstveno mislim na uvjete pozitivnosti i produktivnosti za induktivne i koinduktivne tipove,
te na eliminaciju propozicija kod definiranja nečega u \texttt{Type}.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
