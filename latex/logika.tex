\chapter{Logika prvog reda s induktivnim definicijama}\label{cha:logika-prvog-reda}
U ovom poglavlju predstavljamo glavne rezultate diplomskog rada: formalizaciju
logike prvog reda s induktivnim definicijama \(\mathit{FOL_{ID}}\)
te dokaznog sustava \(\mathit{LKID}\), koje je prvi uveo Brotherston~\cite{brotherston2005}.
Definicije, leme i dokazi u ovom poglavlju preuzete su iz Brotherstonove disertacije~\cite{brotherstonphd}.
Za općeniti uvod u logiku čitatelja upućujemo na knjigu \textit{Matematička logika}~\cite{vukovic}.

Prvo ćemo definirati sintaksu i semantiku logike \(\mathit{FOL_{ID}}\),
nakon čega ćemo definirati njene standardne modele.
Zatim ćemo prikazati dokazni sustav \(\mathit{LKID}\) te konačno dokazati dio adekvatnosti
sustava \(LKID\) s obzirom na standardnu semantiku,
što je ujedno i glavni rezultat ovog diplomskog rada.
\misao{Ovo ću preformulirati ako uspijem dokazati zadnje pravilo.}

Svaka definicija i lema u ovom poglavlju bit će popraćena svojom formalizacijom u Coqu.
Jedan je od ciljeva diplomskog rada prikazati primjene Coqa u matematici,
zbog čega leme nećemo dokazivati \enquote{na papiru},
već se dokaz svake leme može pronaći u repozitoriju rada.\footnote{TODO: repo link, na kraju}
Zainteresiranom čitatelju predlažemo interaktivni prolazak kroz dokaze lema.

Prije no što krenemo na formalizaciju, valja prokomentirati odnos matematičkog i Coqovog vokabulara
što se tiče riječi \enquote{skup}.
U matematici pojam \enquote{skup} može imati dva značenja;
prvo se odnosi na skupove kao \textit{domene diskursa},
dok se drugo odnosi na skupove kao \textit{predikate}, odnosno podskupove domene diskursa.
Primjerice, skup prirodnih brojeva \(\mathbb{N}\) je domena diskursa kada je riječ o svim prirodnim brojevima
te zbog toga pišemo \(n \in \mathbb{N}\) umjesto \(\mathbb{N}(n)\).
S druge strane, skup svih parnih prirodnih brojeva \(E\) je podskup skupa \(\mathbb{N}\), a može se interpretirati
kao predikat na prirodnim brojevima te možemo pisati \(E(n)\) umjesto \(n \in E\).
U Coqu se skupovi kao domene diskursa formaliziraju tipovima sorte \coqset\footnote{Ili općenito kao tipovi sorte \texttt{Type}.},
dok se skupovi kao predikati formaliziraju funkcijama iz domene diskursa u sortu \coqprop.
Na primjer, tip prirodnih brojeva \texttt{nat} je sorte \texttt{Set}, a predikat \texttt{Nat.Even} je tipa \texttt{nat\(\rightarrow\)Prop}.

\section{Sintaksa}\label{sec:sintaksa}
Kao i u svakom izlaganju logike, na početku je potrebno definirati sintaksu.
\begin{definition}\label{def:signatura}
  \textit{Signatura prvog reda s induktivnim predikatima} (kratko: signatura), u oznaci \(\Sigma\),
  je skup simbola od kojih razlikujemo \textit{funkcijske}, \textit{obične predikatne}
  i \textit{induktivne predikatne} simbole.
  \textit{Mjesnost} simbola reprezentiramo funkcijom iz odgovarajućeg skupa simbola u skup \(\mathbb{N}\),
  a označujemo ju s \(|f|\) za funkcijske, odnosno s \(|P|\) za predikatne simbole.
  \begin{minted}{coq}
Structure signature := {
  FuncS : Set;
  fun_ar : FuncS -> nat;
  PredS : Set;
  pred_ar : PredS -> nat;
  IndPredS : Set;
  indpred_ar : IndPredS -> nat
}.
\end{minted}
\end{definition}
\noindent U ostatku poglavlja promatramo jednu proizvoljnu, ali fiksiranu signaturu \(\Sigma\).
Fiksiranje nekog proizvoljnog objekta je česta pojava u matematici,
prvenstveno zato što finksirane argumente ne trebamo spominjati eksplicitno.
Coq omogućuje fiksiranje naredbom \texttt{Context},
pod uvjetom da se korisnik nalazi u okolini \texttt{Section}.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/sections.html}}
Većina definicija i lema u ovom radu su napisane upravo unutar takvih okolina.

\begin{example}
  \misao{\(\Sigma_{PA}\)}
\end{example}


\pagebreak
\begin{definition}\label{def:term}
  \textit{Varijabla} je prirodan broj. \textit{Skup svih terma} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item svaka varijabla je term;
  \item ako je \(f\) funkcijski simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi\footnote{Primijetimo, broj terma ovisi o mjesnosti funkcijskog simbola. U Coqovoj implementaciji ovog \enquote{konstruktora} možemo vidjeti da je on zavisnog tipa.},
    onda je \(f(t_{1}, \ldots, t_{n})\) također term.
  \end{enumerate}
\begin{minted}{coq}
Inductive term : Set :=
| var_term : var -> term 
| TFunc : forall (f : FuncS Σ), vec term (fun_ar f) -> term.
\end{minted}
\end{definition}
\noindent Uobičajene prezentacije logike prvog reda za
skup varijabli uzimaju proizvoljan skup \(\mathcal{V}\),
no za formalizaciju je pogodniji skup prirodnih brojeva \(\mathbb{N}\).
Umjesto eksplicitne kvantifikacije po nekoj varijabli \(v\),
implicitno ćemo kvantificirati po varijabli \(0\).
Ovaj pristup kvantifikaciji\footnote{Ili općenitije, vezivanju varijabli.}, imena \enquote{de Bruijnovo indeksiranje},
bitno olakšava rad sa supstitucijama, a uveden je u članku~\cite{debruijnamelessdummies}.
O samoj implementaciji de Bruijnovog indeksiranja više se može pročitati u knjizi
\textit{Types and Programming Languages}~\cite{pierce2002tapl}.
Za potrebe ovog rada koristili smo program \textit{Autosubst2}\footnote{\url{https://github.com/uds-psl/autosubst2}}~\cite{stark-phd,autosubst2}
za automatsko generiranje tipova terma i formula te pripadajućih funkcija supstitucija i pomoćnih lema.

Princip indukcije za \texttt{term} potrebno je ručno definirati.
Naime, induktivni tip \texttt{term} je \textit{ugniježđen} po konstruktoru \texttt{TFunc} zato što
se javlja omotan oko drugog induktivnog tipa\footnote{Ovdje \texttt{vec}.} kao argument.
Za ugniježđene induktivne tipove, Coq generira neprikladne principe indukcije jer ne zna
kako izraziti tvrdnju \enquote{predikat vrijedi za sve ugniježđene elemente.}
\begin{minted}{coq}
Lemma term_ind
     : forall P : term Σ -> Prop,
         (forall v, P (var_term v)) ->
         (forall f args, (forall st, V.In st args -> P st) ->
                         P (TFunc f args)) ->
       forall t : term Σ, P t.
\end{minted}

\pagebreak
\begin{definition}
  \textit{Skup svih varijabli terma} \(t\), u oznaci \(\mathit{TV}(t)\), konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item \( \mathit{TV}(v) \coloneq \{ v \} \) za varijablu \(v\) i
  \item \( \mathit{TV}(f(t_{1}, \ldots, t_{n})) \coloneq \bigcup_{1 \le i \le n} \mathit{TV}(t_{i}) \) za \(n\)-mjesni funkcijski simbol \(f\) i terme \(t_{1}, \ldots, t_{n}\).
  \end{enumerate}
\begin{minted}{coq}
Inductive TV : term -> var -> Prop :=
| TVVar : forall v, TV (var_term v) v
| TVFunc : forall f args v st, V.In st args ->
                               TV st v -> TV (TFunc f args) v.
\end{minted}
\end{definition}

\begin{definition}\label{def:formula}
  \textit{Skup svih formula} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item ako je \(Q\) (obični ili induktivni) predikatni simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi,
    onda je \(Q(t_{1}, \ldots, t_{n})\) \textit{atomarna} formula;
  \item ako je \(\varphi\) formula, onda su \(\neg\varphi\) i \(\forall\varphi\) također formule;
  \item ako su \(\varphi\) i \(\psi\) formule, onda je \(\varphi \rightarrow \psi\) također formula.
  \end{enumerate}
\begin{minted}{coq}
Inductive formula : Set :=
| FPred (P : PredS Σ) : vec (term Σ) (pred_ar P) -> formula 
| FIndPred (P : IndPredS Σ) : vec (term Σ) (indpred_ar P) -> formula 
| FNeg : formula -> formula 
| FImp : formula -> formula -> formula 
| FAll : formula -> formula.
\end{minted}
  \noindent Ostale veznike definiramo kao sintaksne pokrate.
\begin{minted}{coq}
Definition FAnd (φ ψ : formula) : formula := FNeg (FImp φ (FNeg ψ)).
Definition FOr (φ ψ : formula) : formula := FImp (FNeg φ) ψ.
Definition FExist (φ : formula) : formula := FNeg (FAll (FNeg φ)).
\end{minted}
\end{definition}


\begin{definition}
  \textit{Skup slobodnih varijabli formule} \(\varphi\), u oznaci \(\mathit{FV}(\varphi)\), konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item \( \mathit{FV}(P(u_{1}, \ldots, u_{n})) \coloneq \bigcup_{1 \le i \le n} \mathit{TV}(u_{i}) \),
  \item \( \mathit{FV}(\neg\varphi) \coloneq \mathit{FV}(\varphi)\),
  \item \( \mathit{FV}(\varphi \rightarrow \psi) \coloneq \mathit{FV}(\varphi) \cup \mathit{FV}(\psi) \),
  \item \( \mathit{FV(\forall \varphi)} \coloneq \{ v \mid v + 1 \in \mathit{FV}(\varphi) \} \).
  \end{enumerate}
\begin{minted}{coq}
Inductive FV : formula -> var -> Prop :=
| FV_Pred : forall R args v st,
    V.In st args -> TV st v -> FV (FPred R args) v
| FV_IndPred : forall R args v st,
    V.In st args -> TV st v -> FV (FIndPred R args) v
| FV_Imp_l : forall F G v, FV F v -> FV (FImp F G) v
| FV_Imp_r : forall F G v, FV G v -> FV (FImp F G) v
| FV_Neg : forall F v, FV F v -> FV (FNeg F) v
| FV_All : forall F v, FV F (S v) -> FV (FAll F) v.
\end{minted}
\end{definition}

\begin{definition}
  \textit{Supstitucija} je svaka funkcija iz skupa \(\mathbb{N}\) u skup svih terma.
  Supstituciju \(\sigma\) možemo promatrati kao niz terma \(t_{0}, t_{1}, t_{2}, \ldots\).
  Tada je \textit{pomaknuta supstitucija}, s oznakom \(t \cdot \sigma\), supstitucija koja odgovara nizu \(t, t_{0}, t_{1}, t_{2}, \ldots\), za neki term \(t\).\\
  \noindent Domena supstitucije može se rekurzivno proširiti na skup svih terma i skup svih formula.
\begin{minted}{coq}
Fixpoint subst_term  (σ : var -> term) (t : term) : term :=
  match t with
  | var_term v => σ v
  | TFunc f args => TFunc f (V.map (subst_term σ) args)
  end.
\end{minted}
\begin{minted}{coq}
Fixpoint subst_formula
  (σ : var -> term Σ) (φ : formula )
  : formula  :=
  match φ return formula  with
  | FPred P args => FPred P (V.map (subst_term σ) args)
  | FIndPred P args => FIndPred P (V.map (subst_term σ) args)
  | FNeg ψ => FNeg (subst_formula σ ψ)
  | FImp ψ ξ => FImp (subst_formula σ ψ) (subst_formula σ ξ)
  | FAll ψ => FAll (subst_formula (up_term_term σ) ψ)
  end.
\end{minted}
  \noindent Ovdje funkcija \texttt{up\_term\_term} brine da supstitucija \(\sigma\) mijenja samo one varijable koje nisu vezane.
  \noindent Pišemo \(\varphi[\sigma]\) za primjenu supstitucije \(\sigma\) na formulu \(\varphi\).
  Često korištene supstitucije formula su
  supstitucija varijable \(x\) termom \(t\) u formuli \(\varphi\), s oznakom \(\varphi[t/x]\),
  te supstitucija svake varijable \(n\) u formuli \(\varphi\) varijablom \(n + 1\), s oznakom \(\varphi^{\uparrow}\).
  Iste notacije koristimo i za supstitucije na termima, listama terma i listama formula.
\end{definition}

Konačno, potrebno je definirati sintaksu za indukciju.
U Coqu su definicije induktivnih propozicija proizvoljne do na ograničenje pozitivnosti,
no radi jednostavnosti u \(\mathit{FOL_{ID}}\) su moguće samo
induktivne definicije s atomarnim formulama, a pišemo ih u stilu prirodne dedukcije:
\begin{prooftree}
  \AxiomC{\(  Q_{1}\mathbf{u}_{1}  \ldots   Q_{n}\mathbf{u}_{n}  \)}
  \AxiomC{\(  P_{1}\mathbf{v}_{1}  \ldots   P_{m}\mathbf{v}_{m}  \)}
  \BinaryInfC{\(P\mathbf{t}\)}
\end{prooftree}
\noindent Ovdje su \(Q_{1}, \ldots, Q_{n}\) obični predikatni simboli, \(P_{1}, \ldots, P_{m}\) i \(P\) su induktivni predikatni simboli,
a podebljani znakovi predstavljaju \(n\)-torke terma, gdje je \(n\) mjesnost odgovarajućeg predikata.

\begin{definition}
  Produkcija je uređena četvorka
  \begin{enumerate}
  \item liste parova običnih predikatnih simbola i \(n\)-torki terma odgovarajućih duljina,
  \item liste parova induktivnih predikatnih simbola i \(n\)-torki terma odgovarajućih duljina,
  \item induktivnog predikatnog simbola \(P\) mjesnosti \(m\) i
  \item \(m\)-torke terma.
  \end{enumerate}
\begin{minted}{coq}
Record production :=
  mkProd {
      preds : list { P : PredS Σ & vec (term Σ) (pred_ar P) };
      indpreds : list { P : IndPredS Σ & vec (term Σ) (indpred_ar P) };
      indcons : IndPredS Σ;
      indargs : vec (term Σ) (indpred_ar indcons);
    }.
\end{minted}
  Prvi i drugi član četvorke zovemo \textit{premisama}, a treći i četvrti \textit{konkluzijom}.
  U ostatku rada odabiremo neki podskup skupa svih produkcija koji zovemo
  \textit{skupom induktivnih definicija}, a označavamo s \(\Phi\).
\begin{minted}{coq}
Definition IndDefSet := production -> Prop.
\end{minted}
\end{definition}


\section{Semantika}\label{sec:semantika}
\begin{definition}
  \textit{Struktura prvog reda} (kratko: struktura) je uređena četvorka skupa \(M\) koji nazivamo \textit{nosačem}
  te interpretacija funkcijskih, običnih predikatnih i induktivnih predikatnih simbola.
  Funkcijski simboli mjesnosti \(n\) interpretiraju se kao \(n\)-mjesne funkcije, a predikatni simboli mjesnosti \(n\) kao \(n\)-mjesne relacije na nosaču.
  Koristit ćemo ime nosača kao sinonim za čitavu strukturu,
  a interpretacije označavati s \(f^{M}\) odnosno \(P^{M}\).
\begin{minted}{coq}
Structure structure := {
    domain :> Set;
    interpF (f : FuncS Σ) : vec domain (fun_ar f) -> domain;
    interpP (P : PredS Σ) : vec domain (pred_ar P) -> Prop;
    interpIP (P : IndPredS Σ) : vec domain (indpred_ar P) -> Prop;
  }.
\end{minted}
\end{definition}

\begin{definition}
  Neka je \(M\) proizvoljna struktura. \textit{Okolina} \(\rho\) za \(M\) je proizvoljna funkcija iz skupa prirodnih brojeva u nosač strukture.
\begin{minted}{coq}
Definition env := var -> M.
\end{minted}
  \noindent Okolina se može interpretirati kao niz \(d_{0}, d_{1}, d_{2}, \ldots\). Tada je \textit{pomaknuta okolina}, s oznakom \(d \cdot \rho\),
  niz \(d, d_{0}, d_{1}, d_{2}, \ldots\) za neki \(d \in M\).
  \noindent Proširenje domene okoline \(\rho\) na skup svih terma zovemo \textit{evaluacijom}.
\begin{minted}{coq}
Fixpoint eval (ρ : env) (t : term Σ) : M :=
  match t with
  | var_term x => ρ x
  | TFunc f args => interpF f (V.map (eval ρ) args)
  end.
\end{minted}
  Pišemo \(t^{\rho}\) za evaluaciju terma \(t\) u okolini \(\rho\).
  Istu notaciju koristimo i za evaluaciju \(n\)-torki terma.
\end{definition}

\begin{definition}
  Neka je \(M\) proizvoljna struktura te \(\rho\) okolina za \(M\).
  \textit{Istinitost formule} \(\varphi\) u okolini \(\rho\) pišemo \(\rho \vDash \varphi\),
  a definiramo rekurzivno na način:
  \begin{enumerate}
  \item ako je \(P\) (obični ili induktivni) predikatni simbol mjesnosti \(n\)
    te su \(u_{1}, \ldots, u_{n}\) termi,
    onda vrijedi \(\rho \vDash P(u_{1}, \ldots, u_{n})\) ako i samo ako vrijedi \(P^{M}(\rho(u_{1}), \ldots, \rho(u_{n}))\),
  \item vrijedi \(\rho \vDash \neg \varphi \) ako i samo ako ne vrijedi \(\rho \vDash \varphi\) (što još pišemo \(\rho \not \vDash \varphi\)),
  \item vrijedi \(\rho \vDash \varphi \rightarrow \psi \) ako i samo ako vrijedi \(\rho \not \vDash \varphi\) ili \(\rho \vDash \psi\) i
  \item vrijedi \(\rho \vDash \forall \varphi\) ako i samo ako za sve \(d \in M\) vrijedi \(d \cdot \rho \vDash \varphi\)
  \end{enumerate}
\begin{minted}{coq}
Fixpoint Sat (ρ : env M) (F : formula Σ) : Prop :=
  match F with
    | FPred P args => interpP P (V.map (eval ρ) args)
    | FIndPred P args => interpIP P (V.map (eval ρ) args)
    | FNeg G => ~ Sat ρ G
    | FImp F G => Sat ρ F -> Sat ρ G
    | FAll G => forall d, Sat (d .: ρ) G
  end.
\end{minted}
\end{definition}

\begin{lemma}
  Neka su \(\varphi\), \(\sigma\), \(M\) i \(\rho\) redom
  proizvoljna formula, supstitucija, struktura i okolina za \(M\).
  Tada vrijedi \(\rho \vDash \varphi[\sigma]\) ako i samo ako vrijedi \( (t \mapsto t^{\rho}) \, \circ \, \sigma \vDash \varphi\).
\begin{minted}{coq}
Lemma strong_form_subst_sanity2 :
  forall (φ : formula Σ) (σ : var -> term Σ)
      (M : structure Σ) (ρ : env M),
      ρ ⊨ (subst_formula σ φ) <-> (σ >> eval ρ) ⊨ φ.
\end{minted}
  \noindent Kompoziciju supstitucije \(\sigma\) i evaluacije \(t \mapsto t^{\rho}\)
  možemo nazvati \textit{semantičkom} supstitucijom
  jer prvo provodi \textit{sintaktičku} supstituciju \(\sigma\) nakon čega provodi evaluaciju.
  Tada možemo neformalno reći da sintaktička i semantička supstitucija
  komutiraju pod relacijom istinitosti.
\end{lemma}
% \misao{Ne znam zašto, ali meni se simbol \(\mapsto\) (\verb|\mapsto|)
% prikazuje kao kombinacija \(\vdash \rightarrow\) (\verb|\vdash \rightarrow|) u PDF-u.}

\section{Standardni modeli}\label{sec:standardni-modeli}
Želimo ograničiti semantička razmatranja na samo one strukture koje \enquote{imaju smisla} za induktivne predikate.
Prisjetimo se, predikatni simbol \(P\) mjesnosti \(n\) interpretira se na strukturi \(M\)  podskupom skupa \(M^{n}\).
Indukciju smatramo dokazivanjem \textup{u razinama} pa ima smisla promatrati \textit{razine interpretacije} induktivnog predikata,
gdje je nulta razina prazan skup,
a svaku iduću razinu konstruiramo pomoću produkcija induktivnog skupa definicija i prethodnih razina.
Tako je prva razina onaj podskup kojeg možemo dobiti najviše jednom \enquote{primjenom produkcija},
druga je razina onaj podskup kojeg možemo dobiti pomoću najviše dviju primjena produkcija, i tako dalje.
Na taj se način, korak po korak, gradi \textit{smislena} interpretacija induktivnih predikata.
Napominjemo da se zbog mogućih međuovisnosti induktivnih predikata razine interpretacije definiraju simultano.
Ovaj odjeljak posvećujemo formalizaciji ovih pojmova.

\begin{definition}
  Neka je \(M\) proizvoljna struktura te neka je \(pr\) proizvoljna produkcija induktivnog skupa definicija \(\Phi\), primjerice:
  \begin{prooftree}
  \AxiomC{\(  Q_{1}\mathbf{u}_{1}  \ldots   Q_{n}\mathbf{u}_{n}  \)}
  \AxiomC{\(  P_{1}\mathbf{v}_{1}  \ldots   P_{m}\mathbf{v}_{m}  \)}
  \BinaryInfC{\(P\mathbf{t}\)}
  \end{prooftree}
\noindent Neka je \(f\) proizvoljna interpretacija induktivnih predikatnih simbola.
Tada definiramo \(\varphi_{pr}(f)\) kao skup svih \(|P|\)-torki \(\mathbf{d}\) elemenata nosača \(M\) za koje postoji okolina \(\rho\) za \(M\) takva da:
\begin{itemize}
\item za sve \( i \in \{ 1, \ldots, n \} \) vrijedi \( \mathbf{u}_{i}^{\rho} \in Q_{i}^{M} \), % TODO uvesti ovu notaciju za u
\item za sve \( j \in \{ 1, \ldots, m \} \) vrijedi \( \mathbf{v_{i}^{\rho}} \in f(P_{i}) \) i
\item \(\mathbf{d} = \mathbf{t}^{\rho}\).
\end{itemize}
\begin{minted}{coq}
Definition φ_pr
  (pr : production)
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
  (ds : vec D (indpred_ar (indcons pr)))
  : Prop :=
      exists (ρ : env M),
      (forall Q us, List.In (Q; us) (preds pr) ->
               interpP Q (V.map (eval ρ) us)) /\
        (forall P ts, List.In (P; ts) (indpreds pr) ->
                  args P (V.map (eval ρ) ts)) /\
        ds = V.map (eval ρ) (indargs pr).
\end{minted}
\noindent Operator \(\varphi_{pr}\) je formalizacija ideje primjene produkcije.
Nadalje, potrebno je definirati operator koji će uzeti u obzir \textit{sve} produkcije koje se odnose na \(P\).
Definiramo \(\varphi_{P}(f)\) kao uniju svih \(\varphi_{pr^{\prime}}(f)\)
gdje je \(pr^{\prime}\) produkcija u kojoj se \(P\) javlja u konkluziji.
\begin{minted}{coq}
Definition φ_P
  (P : IndPredS Σ)
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
  : vec D (indpred_ar P) -> Prop.
  refine (fun ds => _).
  refine (@ex production (fun pr => _)).
  refine (@ex (P = indcons pr /\ Φ pr) (fun '(conj Heq HΦ) => _)).
  rewrite Heq in ds.
  exact (φ_pr pr args ds).
Defined.
\end{minted}
\noindent Konačno, definiramo operator skupa definicija \(\varphi_{\Phi}\) kao preslikavanje
koje svakom induktivnom predikatnom simbolu \(P\) pridružuje skup \(\varphi_{P}(f)\).
\begin{minted}{coq}
Definition φ_Φ
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
    : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop :=
    fun P => φ_P P args.
\end{minted}
\noindent Operator \(\varphi_{\Phi}\) omogućuje simultanu primjenu produkcija.
\end{definition}

\begin{remark}
  Kako je funkcija \(f\) bila uvedena na samom početku prethodne definicije,
  u stvari definicija operatora \(\varphi_{\Phi}\) glasi
  \(
    \varphi_{\Phi}(f)(P) \coloneq \varphi_{P}(f)
  \).
\end{remark}

\misao{TODO: primjer.}

\begin{proposition}
  Operator \(\varphi_{\Phi}\) je monoton.
\begin{minted}{coq}
Proposition φ_Φ_monotone :
  forall (f g : forall P, vec D (indpred_ar P) -> Prop),
    (forall P v, f P v -> g P v) ->
    (forall P v, φ_Φ f P v -> φ_Φ g P v).
\end{minted}
\end{proposition}

\begin{definition}
  Neka je \(M\) proizvoljna struktura.
  Definiramo aproksimaciju skupa induktivnih definicija \(\Phi\) razine \(\alpha \in \mathbb{N}\), u oznaci \(\varphi_{\Phi}^{\alpha}\), rekurzivno na način:
  \begin{enumerate}
  \item \( \varphi_{\Phi}^{0}(P) \coloneq \varnothing \) i
  \item \( \varphi_{\Phi}^{\alpha + 1} \coloneq \varphi_{\Phi}(\varphi_{\Phi}^{\alpha}) \).
  \end{enumerate}
\begin{minted}{coq}
Fixpoint φ_Φ_n P (α : nat) (v : vec M (indpred_ar P)) : Prop :=
  match α with
  | 0 => False
  | S α => @φ_Φ Σ M Φ (fun P => φ_Φ_n P α) P v
  end.
\end{minted}
  \noindent Tada je \textit{aproksimant} induktivnog predikatnog simbola \(P\) razine \(\alpha\) upravo \(\varphi_{\Phi}^{\alpha}(P)\).
\begin{minted}{coq}
Definition approximant_of (P : IndPredS Σ)
  : nat -> vec M (indpred_ar P) -> Prop :=
  φ_Φ_n P.
\end{minted}
\end{definition}

\begin{remark}
  Brotherston je definirao aproksimaciju razine \(\alpha\) za pojedini induktivni predikatni simbol
  kao uniju aproksimacija svih nižih razina
  Takva je definicija ekvivalentna našoj.
\end{remark}

\begin{lemma}\label{lemma:ekvivalentnost-definicija-aproksimacija}
  Za svaki prirodni broj \(\alpha\) i induktivni predikatni simbol \(P\) vrijedi
  \[
    \varphi_{\Phi}^{\alpha}(P) = \bigcup_{\beta < \alpha} \varphi_{\Phi}^{\beta}(P).
  \]
\begin{minted}{coq}
Lemma approximant_characterization : forall α P v,
      φ_Φ_n P α v <-> exists β,
                      β < α /\ @φ_Φ Σ M Φ (fun P => φ_Φ_n P β) P v.
\end{minted}
\end{lemma}

\begin{definition}
  \textit{Aproksimacija razine} \(\omega\), u oznaci \(\varphi_{\Phi}^{\omega}\), je za svaki pojedini predikatni simbol
  unija aproksimacija razina manjih od \(\omega\).
\begin{minted}{coq}
Definition φ_Φ_ω P v := exists α, φ_Φ_n P α v.
\end{minted}
\end{definition}

\begin{lemma}\label{lemma:omega-least-prefixed}
  Aproksimacija razine \(\omega\) je najmanji skup sa svojstvom \(\varphi_{\Phi}(\varphi_{\Phi}^{\omega}) \subseteq \varphi_{\Phi}^{\omega}\).
\begin{minted}{coq}
Lemma ω_prefixed : forall P v, @φ_Φ Σ M Φ φ_Φ_ω P v -> φ_Φ_ω P v.
Lemma ω_least : forall args,
                (forall P v, @φ_Φ Σ M Φ args P v -> args P v) ->
                forall P v, φ_Φ_ω P v -> args P v.
\end{minted}
\end{lemma}

\begin{definition}
  Kažemo da je struktura \(M\) \textit{standardni model} za \(\Phi\) ako
  interpretira svaki induktivni predikatni simbol njegovim aproksimantom razine \(\omega\).
\begin{minted}{coq}
Definition standard_model
  (Σ : signature) (Φ: @IndDefSet Σ) (M : structure Σ) : Prop :=
  forall (P : IndPredS Σ) ts, interpIP P ts <-> @φ_Φ_ω Σ M Φ P ts.
\end{minted}
\end{definition}
\noindent Prema lemi~\ref{lemma:omega-least-prefixed}, standardni model je
najmanja struktura koja ima smisla za zadani skup induktivnih definicija.


\section{Sistem sekvenata s induktivnim definicijama}\label{sec:sistem-sekvenata}
Cilj je ovog odjeljka definirati dokazni sustav \(\mathit{LKID}\) za logiku \(\mathit{FOL_{ID}}\).
Ovaj dokazni sustav temelji se na Gentzenovu računu sekvenata, a proširen je lijevim i desnim pravilima za indukciju.
Prije no što definiramo \(\mathit{LKID}\), potrebno je definirati pojam sekvente i međusobne zavisnosti induktivnih predikata.

\begin{definition}
  Neka su \(\Gamma\) i \(\Delta\) proizvoljne liste formula. Tada je \textit{sekventa} uređeni par \((\Gamma,\Delta)\), a označavamo ju s \(\Gamma \vdash \Delta\).
\begin{minted}{coq}
Inductive sequent : Set :=
| mkSeq (Γ Δ : list (formula Σ)).
\end{minted}
\end{definition}
\noindent Sekventom \(\Gamma \vdash \Delta\) konceptualno tvrdimo da istinitost \textit{svake}
tvrdnje u \(\Gamma\) povlači istinitost \textit{neke} tvrdnje u \(\Delta\).
Kažemo da je sekventa \(\Gamma \vdash \Delta\) \textit{dokaziva}, ili da iz \(\Gamma\) postoji izvod za \(\Delta\), ako u sustavu \(\mathit{LKID}\) postoji \textit{dokaz} za \(\Gamma \vdash \Delta\). Pojam dokaza ćemo precizirati kasnije.

\begin{definition}
  Neka su \(P_{i}\) i \(P_{j}\) proizvoljni induktivni predikatni simboli.
  Kažemo da je simbol \(P_{i}\) u \textit{relaciji} \(\mathit{Prem}\) sa simbolom \(P_{j}\)
  ako postoji produkcija u skupu induktivnih definicija \(\Phi\) takva da
  se simbol \(P_{i}\) javlja u njenoj konkluziji te
  se simbol \(P_{j}\) javlja u njenim premisama.
\begin{minted}{coq}
Definition Prem (Pi Pj : IndPredS Σ) :=
  exists pr, Φ pr /\
             indcons pr = Pi /\
             exists ts, List.In (Pj; ts) (indpreds pr).
\end{minted}
\end{definition}

\begin{definition}
  Definiramo relaciju \(\mathit{Prem}^{\ast}\) kao refleksivno i tranzitivno zatvorenje relacije \(\mathit{Prem}\) na skupu induktivnih predikatnih simbola.
\begin{minted}{coq}
Definition Prem_star := clos_refl_trans (IndPredS Σ) Prem.
\end{minted}
  \noindent Za induktivne predikatne simbole \(P\) i \(Q\) kažemo da su
  \textit{međusobno zavisni} ako vrijedi \(\mathit{Prem}^{\ast}(P, Q)\) i \(\mathit{Prem}^{\ast}(Q, P)\).
\begin{minted}{coq}
Definition mutually_dependent (P Q : IndPredS Σ) :=
  Prem_star P Q /\ Prem_star Q P.
\end{minted}
\end{definition}

\begin{lemma}
  Međusobna zavisnost je relacija ekvivalencije na skupu induktivnih predikatnih simbola.
\begin{minted}{coq}
Lemma mutually_dependent_equiv : equiv (IndPredS Σ) mutually_dependent.
\end{minted}
\end{lemma}

Sustav \(\mathit{LKID}\) sastoji se od četiri vrste pravila izvoda.
\textit{Strukturalna pravila} služe baratanju strukturom sekventi,
a prikazana su na slici~\ref{fig:lkid-structural}.
\textit{Propozicijska pravila} služe propozicijskom logičkom zaključivanju,
a prikazana su na slici~\ref{fig:lkid-propositional}.

\begin{figure}[!htb]
  \centering

  \begin{prooftree}
    \AxiomC{\(\Gamma \cap \Delta \not = \varnothing \)}
    \RightLabel{\( \mathit{ (Ax) } \)}
    \UnaryInfC{\( \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\(\Gamma^{\prime} \vdash \Delta^{\prime}\)}
    \AxiomC{\(\Gamma^{\prime} \subseteq \Gamma\)}
    \AxiomC{\(\Delta^{\prime} \subseteq \Delta\)}
    \RightLabel{\( \mathit{ (Wk) } \)}
    \TrinaryInfC{\(\Gamma \subseteq \Delta\)}
  \end{prooftree}
  
  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta\)}
    \AxiomC{\( \varphi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (Cut) } \)}
    \BinaryInfC{\( \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (Subst) } \)}
    \UnaryInfC{\( \Gamma[\sigma] \vdash \Delta[\sigma] \)}
  \end{prooftree}
  
  \caption{Strukturalna pravila sustava \(\mathit{LKID}\).}\label{fig:lkid-structural}
\end{figure}

\begin{figure}[!htb]
  \centering
  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta \)}
    \RightLabel{\( \mathit{ (NegL) } \)}
    \UnaryInfC{\( \neg \varphi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (NegR) } \)}
    \UnaryInfC{\( \Gamma \vdash \neg \varphi, \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta \)}
    \AxiomC{\( \psi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (ImpL) } \)}
    \BinaryInfC{\( \varphi \rightarrow \psi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma \vdash \psi, \Delta \)}
    \RightLabel{\( \mathit{ (ImpR) } \)}
    \UnaryInfC{\( \Gamma \vdash \varphi \rightarrow \psi, \Delta \)}
  \end{prooftree}
  
  \caption{Propozicijska pravila sustava \(\mathit{LKID}\).}\label{fig:lkid-propositional}
\end{figure}

Kvantifikacijska pravila prikazana su na slici~\ref{fig:lkid-quantificational}, a odnose se na univerzalnu kvantifikaciju.
Supstitucija \(\sigma_{\mathit{id}}\) je supstitucija identiteta.
Lijevo pravilo za kvantifikaciju kaže da dokaz
koji počinje s instanciranom formulom \(\varphi\) u kojoj se javlja term \(t\) na mjestu varijable \(0\) isto tako smije
započeti s univerzalno kvantificiranom formulom \(\forall\varphi\).
Za desno pravilo kvantifikacije primijetimo da se varijabla \(0\) ne javlja u listama \(\Gamma^{\uparrow}\) i \(\Delta^{\uparrow}\) zbog pomicanja.
Kako naše formule zbog de Bruijnovog indeksiranja implicitno kvantificiraju po varijabli \(0\),
a varijabla \(0\) se možda javlja u formuli \(\varphi\),
ustvari je dokaz sekventa \(\Gamma \vdash \forall\varphi, \Delta\) posve analogan
dokazu sekventa \(\Gamma^{\uparrow} \vdash \varphi, \Delta\).
\misao{Ovo vjerojatno treba preformulirati.}
\begin{figure}[!htb]
  \centering
  \begin{prooftree}
    \AxiomC{\( \varphi[t \cdot \sigma_{\mathit{id}}], \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (AllL) } \)}
    \UnaryInfC{\( \forall\varphi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma^{\uparrow} \vdash \varphi, \Delta^{\uparrow}\)}
    \RightLabel{\( \mathit{ (AllR) } \)}
    \UnaryInfC{\( \Gamma \vdash \forall\varphi, \Delta \)}
  \end{prooftree}
  \caption{Kvantifikacijska pravila sustava \(\mathit{LKID}\).}\label{fig:lkid-quantificational}
\end{figure}


\begin{minted}{coq}
Inductive LKID : sequent -> Prop := 
  (* Structural rules. *)
  | Ax : forall Γ Δ φ, In φ Γ -> In φ Δ -> LKID (Γ ⊢ Δ)
  | Wk : forall Γ' Δ' Γ Δ,
      Γ' ⊆ Γ ->
      Δ' ⊆ Δ ->
      LKID (Γ' ⊢ Δ') ->
      LKID (Γ ⊢ Δ)
  | Cut : forall Γ Δ φ,
      LKID (Γ ⊢ φ :: Δ) ->
      LKID (φ :: Γ ⊢ Δ) ->
      LKID (Γ ⊢ Δ)
  | Subst : forall Γ Δ,
      LKID (Γ ⊢ Δ) ->
      forall σ, LKID (map (subst_formula σ) Γ ⊢ map (subst_formula σ) Δ)
  (* Propositional rules. *)
  | NegL : forall Γ Δ φ, LKID (Γ ⊢ φ :: Δ) -> LKID (FNeg φ :: Γ ⊢ Δ)
  | NegR : forall Γ Δ φ, LKID (φ :: Γ ⊢ Δ) -> LKID (Γ ⊢ FNeg φ :: Δ)
  | ImpL : forall Γ Δ φ ψ,
      LKID (Γ ⊢ φ :: Δ) -> LKID (ψ :: Γ ⊢ Δ) ->
      LKID (FImp φ ψ :: Γ ⊢ Δ)
  | ImpR : forall Γ Δ φ ψ,
      LKID (φ :: Γ ⊢ ψ :: Δ) -> LKID (Γ ⊢ (FImp φ ψ) :: Δ)
  (* Quantifier rules. *)
  | AllL : forall Γ Δ φ t,
      LKID (subst_formula (t .: ids) φ :: Γ ⊢ Δ) -> 
      LKID (FAll φ :: Γ ⊢ Δ)
  | AllR : forall Γ Δ φ,
      LKID (shift_formulas Γ ⊢ φ :: shift_formulas Δ) ->
      LKID (Γ ⊢ (FAll φ) :: Δ)
  | IndL : forall Γ Δ (Pj : IndPredS Σ) (u : vec (term Σ) (indpred_ar Pj))
             (z_i : forall P, vec var (indpred_ar P)) (* dodati pretpostavku forall P, NoDup (z_i P)? *)
             (G_i : IndPredS Σ -> formula Σ)
             (HG2 : forall Pi, ~mutually_dependent Pi Pj -> G_i Pi = FIndPred Pi (V.map var_term (z_i Pi))),
      let maxΓ := max_fold (map some_var_not_in_formula Γ) in
      let maxΔ := max_fold (map some_var_not_in_formula Δ) in
      let maxP := some_var_not_in_formula (FIndPred Pj u) in
      let shift_factor := max maxP (max maxΓ maxΔ) in
      let Fj := subst_formula (finite_subst (z_i Pj) u) (G_i Pj) in
      let minor_premises :=
        (forall pr (Hdep : mutually_dependent (indcons pr) Pj),
            let Qs := shift_formulas_by shift_factor (FPreds_from_preds (preds pr)) in
            let Gs := map (fun '(P; args) =>
                             let shifted_args := V.map (shift_term_by shift_factor) args in
                             let σ := finite_subst (z_i P) (shifted_args) in
                             let G := G_i P in
                             subst_formula σ G)
                        (indpreds pr) in
            let Pi := indcons pr in
            let ty := V.map (shift_term_by shift_factor) (indargs pr) in
            let Fi := subst_formula (finite_subst (z_i Pi) ty) (G_i Pi) in
            LKID (Qs ++ Gs ++ Γ ⊢ Fi :: Δ))
      in
      minor_premises ->
      LKID (Fj :: Γ ⊢ Δ) ->
      LKID (FIndPred Pj u :: Γ ⊢ Δ)
  | IndR : forall Γ Δ pr σ,
      Φ pr ->
      (forall Q us, In (Q; us) (preds pr) ->
               LKID (Γ ⊢ (FPred Q (V.map (subst_term σ) us) :: Δ))) ->
      (forall P ts, In (P; ts) (indpreds pr) ->
               LKID (Γ ⊢ (FIndPred P (V.map (subst_term σ) ts) :: Δ))) ->
      LKID ( Γ ⊢ FIndPred (indcons pr) (V.map (subst_term σ) (indargs pr)) :: Δ).
\end{minted}

Za neko pravilo izvoda kažemo da je \textit{dopustivo} ako nije u definiciji sustava \(\mathit{LKID}\),
ali je iz originalnih pravila izvedivo.
\begin{example}
  Obično se kod definicije sistema sekvenata za varijacije logike prvog reda dodaju i pravila za egzistencijalnu kvantifikaciju.
  Lijevo i desno pravilo za egzistencijalnu kvantifikaciju je dopustivo u sustavu \(\mathit{LKID}\).
\end{example}

\section{Adekvatnost}\label{sec:adekvatnost}
Lokalne adekvatnosti za pravila izvoda. Glavni teorem.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
