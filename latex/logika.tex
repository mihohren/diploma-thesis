\chapter{Logika prvog reda s induktivnim definicijama}\label{cha:logika-prvog-reda}
U ovom poglavlju predstavljamo glavne rezultate diplomskog rada: formalizaciju
logike prvog reda s induktivnim definicijama \(\mathit{FOL_{ID}}\)
te dokaznog sustava \(\mathit{LKID}\), koje je prvi uveo Brotherston~\cite{brotherston2005}.
Definicije, leme i dokazi u ovom poglavlju preuzete su iz Brotherstonove disertacije~\cite{brotherstonphd}.
Za općeniti uvod u logiku čitatelja upućujemo na knjigu \textit{Matematička logika}~\cite{vukovic}.

Prvo ćemo definirati sintaksu i semantiku logike \(\mathit{FOL_{ID}}\),
nakon čega ćemo definirati njene standardne modele.
Zatim ćemo prikazati dokazni sustav \(\mathit{LKID}\) te konačno dokazati dio adekvatnosti
sustava \(LKID\) s obzirom na standardnu semantiku,
što je ujedno i glavni rezultat ovog diplomskog rada.
\misao{Ovo ću preformulirati ako uspijem dokazati zadnje pravilo.}

Svaka definicija i lema u ovom poglavlju bit će popraćena svojom formalizacijom u Coqu.
Jedan je od ciljeva diplomskog rada prikazati primjene Coqa u matematici,
zbog čega leme nećemo dokazivati \enquote{na papiru},
već se dokaz svake leme može pronaći u repozitoriju rada.\footnote{TODO: repo link, na kraju}
Zainteresiranom čitatelju predlažemo interaktivni prolazak kroz dokaze lema.

Prije no što krenemo na formalizaciju, valja prokomentirati odnos matematičkog i Coqovog vokabulara
što se tiče riječi \enquote{skup}.
U matematici pojam \enquote{skup} može imati dva značenja;
prvo se odnosi na skupove kao \textit{domene diskursa},
dok se drugo odnosi na skupove kao \textit{predikate}, odnosno podskupove domene diskursa.
Primjerice, skup prirodnih brojeva \(\mathbb{N}\) je domena diskursa kada je riječ o svim prirodnim brojevima
te zbog toga pišemo \(n \in \mathbb{N}\) umjesto \(\mathbb{N}(n)\).
S druge strane, skup svih parnih prirodnih brojeva \(E\) je podskup skupa \(\mathbb{N}\), a može se interpretirati
kao predikat na prirodnim brojevima te možemo pisati \(E(n)\) umjesto \(n \in E\).
U Coqu se skupovi kao domene diskursa formaliziraju tipovima sorte \coqset\footnote{Ili općenito kao tipovi sorte \texttt{Type}.},
dok se skupovi kao predikati formaliziraju funkcijama iz domene diskursa u sortu \coqprop.
Na primjer, tip prirodnih brojeva \texttt{nat} je sorte \texttt{Set}, a predikat \texttt{Nat.Even} je tipa \texttt{nat\(\rightarrow\)Prop}.

\section{Sintaksa}\label{sec:sintaksa}
Kao i u svakom izlaganju logike, na početku je potrebno definirati sintaksu.
\begin{definition}\label{def:signatura}
  \textit{Signatura prvog reda s induktivnim predikatima} (kratko: signatura), u oznaci \(\Sigma\),
  je skup simbola od kojih razlikujemo \textit{funkcijske}, \textit{obične predikatne}
  i \textit{induktivne predikatne} simbole.
  \textit{Mjesnost} simbola reprezentiramo funkcijom iz odgovarajućeg skupa simbola u skup \(\mathbb{N}\),
  a označujemo ju s \(|f|\) za funkcijske, odnosno s \(|P|\) za predikatne simbole.
  \begin{minted}{coq}
Structure signature := {
  FuncS : Set;
  fun_ar : FuncS -> nat;
  PredS : Set;
  pred_ar : PredS -> nat;
  IndPredS : Set;
  indpred_ar : IndPredS -> nat
}.
\end{minted}
\end{definition}
\begin{example}
  Funkcijski simboli Peanove aritmetike su redom simbol nule \(o\) (mjesnosti \(0\)),
  simbol sljedbenika \(s\) (mjesnosti \(1\))
  te simboli \(+\) za zbroj i \(\cdot\) za umnožak (mjesnosti \(2\)).
\begin{minted}{coq}
Inductive Func__PA :=
| PA_zero
| PA_succ
| PA_add
| PA_mult.
Definition fun_ar__PA (s : Func__PA) : nat :=
  match s with
  | PA_zero => 0
  | PA_succ => 1
  | PA_add  => 2
  | PA_mult => 2
  end.
\end{minted}
  \noindent Simbol jednakosti \(=\) (mjesnosti \(2\)) je jedini običan predikatni simbol
  Peanove aritmetike.
\begin{minted}{coq}
Inductive Pred__PA := PA_eq.
Definition pred_ar__PA (s : Pred__PA) : nat :=
  match s with
  | PA_eq => 2
  end.
\end{minted}
  \noindent Definiramo induktivne predikatne simbole \(N\), \(E\) i \(O\) koje ćemo
  interpretirati redom kao predikate \enquote{biti prirodan broj}, \enquote{biti paran broj} te
  \enquote{biti neparan broj}.
\begin{minted}{coq}
Inductive IndPred__PA :=
| PA_Nat
| PA_Even
| PA_Odd.
Definition indpred_ar__PA (s : IndPred__PA) : nat :=
  match s with
  | PA_Nat => 1
  | PA_Even => 1
  | PA_Odd => 1
  end.
\end{minted}
  \noindent Konačno, \textit{proširena Peanova signatura}, s oznakom \(\Sigma_{\mathit{PA}}\), je signatura za
  Peanovu aritmetiku prvog reda s prethodno definiranim induktivnim predikatnim simbolima.
\begin{minted}{coq}
Definition Σ__PA : signature
  := {|
    FuncS := Func__PA;
    fun_ar := fun_ar__PA;
    PredS := Pred__PA;
    pred_ar := pred_ar__PA;
    IndPredS := IndPred__PA;
    indpred_ar := indpred_ar__PA;
  |}.
\end{minted}
\end{example}
\noindent U ostatku poglavlja promatramo jednu proizvoljnu, ali fiksiranu signaturu \(\Sigma\).
Fiksiranje nekog proizvoljnog objekta je česta pojava u matematici,
prvenstveno zato što finksirane argumente ne trebamo spominjati eksplicitno.
Coq omogućuje fiksiranje naredbom \texttt{Context},
pod uvjetom da se korisnik nalazi u okolini \texttt{Section}.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/sections.html}}
Većina definicija i lema u ovom radu su napisane upravo unutar takvih okolina.


\pagebreak
\begin{definition}\label{def:term}
  \textit{Varijabla} je prirodan broj. \textit{Skup svih terma} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item svaka varijabla je term;
  \item ako je \(f\) funkcijski simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi\footnote{Primijetimo, broj terma ovisi o mjesnosti funkcijskog simbola. U Coqovoj implementaciji ovog \enquote{konstruktora} možemo vidjeti da je on zavisnog tipa.},
    onda je \(f(t_{1}, \ldots, t_{n})\) također term.
  \end{enumerate}
\begin{minted}{coq}
Inductive term : Set :=
| var_term : var -> term 
| TFunc : forall (f : FuncS Σ), vec term (fun_ar f) -> term.
\end{minted}
\end{definition}
\noindent Uobičajene prezentacije logike prvog reda za
skup varijabli uzimaju proizvoljan skup \(\mathcal{V}\),
no za formalizaciju je pogodniji skup prirodnih brojeva \(\mathbb{N}\).
Umjesto eksplicitne kvantifikacije po nekoj varijabli \(v\),
implicitno ćemo kvantificirati po varijabli \(0\).
Ovaj pristup kvantifikaciji\footnote{Ili općenitije, vezivanju varijabli.}, imena \enquote{de Bruijnovo indeksiranje},
bitno olakšava rad sa supstitucijama, a uveden je u članku~\cite{debruijnamelessdummies}.
O samoj implementaciji de Bruijnovog indeksiranja više se može pročitati u knjizi
\textit{Types and Programming Languages}~\cite{pierce2002tapl}.
Za potrebe ovog rada koristili smo program \textit{Autosubst2}\footnote{\url{https://github.com/uds-psl/autosubst2}}~\cite{stark-phd,autosubst2}
za automatsko generiranje tipova terma i formula te pripadajućih funkcija supstitucija i pomoćnih lema.

Princip indukcije za \texttt{term} potrebno je ručno definirati.
Naime, induktivni tip \texttt{term} je \textit{ugniježđen} po konstruktoru \texttt{TFunc} zato što
se javlja omotan oko drugog induktivnog tipa\footnote{Ovdje \texttt{vec}.} kao argument.
Za ugniježđene induktivne tipove, Coq generira neprikladne principe indukcije jer ne zna
kako izraziti tvrdnju \enquote{predikat vrijedi za sve ugniježđene elemente.}
\begin{minted}{coq}
Lemma term_ind
     : forall P : term Σ -> Prop,
         (forall v, P (var_term v)) ->
         (forall f args, (forall st, V.In st args -> P st) ->
                         P (TFunc f args)) ->
       forall t : term Σ, P t.
\end{minted}

\pagebreak
\begin{definition}
  \textit{Skup svih varijabli terma} \(t\), u oznaci \(\mathit{TV}(t)\), konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item \( \mathit{TV}(v) \coloneq \{ v \} \) za varijablu \(v\) i
  \item \( \mathit{TV}(f(t_{1}, \ldots, t_{n})) \coloneq \bigcup_{1 \le i \le n} \mathit{TV}(t_{i}) \) za \(n\)-mjesni funkcijski simbol \(f\) i terme \(t_{1}, \ldots, t_{n}\).
  \end{enumerate}
\begin{minted}{coq}
Inductive TV : term -> var -> Prop :=
| TVVar : forall v, TV (var_term v) v
| TVFunc : forall f args v st, V.In st args ->
                               TV st v -> TV (TFunc f args) v.
\end{minted}
\end{definition}

\begin{definition}\label{def:formula}
  \textit{Skup svih formula} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item ako je \(Q\) (obični ili induktivni) predikatni simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi,
    onda je \(Q(t_{1}, \ldots, t_{n})\) \textit{atomarna} formula;
  \item ako je \(\varphi\) formula, onda su \(\neg\varphi\) i \(\forall\varphi\) također formule;
  \item ako su \(\varphi\) i \(\psi\) formule, onda je \(\varphi \rightarrow \psi\) također formula.
  \end{enumerate}
\begin{minted}{coq}
Inductive formula : Set :=
| FPred (P : PredS Σ) : vec (term Σ) (pred_ar P) -> formula 
| FIndPred (P : IndPredS Σ) : vec (term Σ) (indpred_ar P) -> formula 
| FNeg : formula -> formula 
| FImp : formula -> formula -> formula 
| FAll : formula -> formula.
\end{minted}
  \noindent Ostale veznike definiramo kao sintaksne pokrate.
\begin{minted}{coq}
Definition FAnd (φ ψ : formula) : formula := FNeg (FImp φ (FNeg ψ)).
Definition FOr (φ ψ : formula) : formula := FImp (FNeg φ) ψ.
Definition FExist (φ : formula) : formula := FNeg (FAll (FNeg φ)).
\end{minted}
\end{definition}

\begin{example}
  U proširenoj Peanovoj signaturi, svojstvo \enquote{svaki prirodan broj je paran ili neparan}
  možemo izraziti formulom \( \forall x, N(x) \rightarrow E(x) \lor O(x) \).
\begin{minted}{coq}
Definition every_nat_is_even_or_odd : formula Σ__PA :=
  FAll
    (FImp
       (@FIndPred Σ__PA PA_Nat ([var_term 0]))
       (FOr
          (@FIndPred Σ__PA PA_Even ([var_term 0]))
          (@FIndPred Σ__PA PA_Odd ([var_term 0])))).
\end{minted}
  \noindent Ovdje vidimo učinak de Bruijnovog indeksiranja na formule;
  umjesto eksplicitnog navođenja varijable \(x\) kod kvantifikacije,
  implicitno kvantificiramo po varijabli \(0\).
\end{example}

\begin{definition}
  \textit{Skup slobodnih varijabli formule} \(\varphi\), u oznaci \(\mathit{FV}(\varphi)\), konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item \( \mathit{FV}(P(u_{1}, \ldots, u_{n})) \coloneq \bigcup_{1 \le i \le n} \mathit{TV}(u_{i}) \),
  \item \( \mathit{FV}(\neg\varphi) \coloneq \mathit{FV}(\varphi)\),
  \item \( \mathit{FV}(\varphi \rightarrow \psi) \coloneq \mathit{FV}(\varphi) \cup \mathit{FV}(\psi) \),
  \item \( \mathit{FV(\forall \varphi)} \coloneq \{ v \mid v + 1 \in \mathit{FV}(\varphi) \} \).
  \end{enumerate}
\begin{minted}{coq}
Inductive FV : formula -> var -> Prop :=
| FV_Pred : forall R args v st,
    V.In st args -> TV st v -> FV (FPred R args) v
| FV_IndPred : forall R args v st,
    V.In st args -> TV st v -> FV (FIndPred R args) v
| FV_Imp_l : forall F G v, FV F v -> FV (FImp F G) v
| FV_Imp_r : forall F G v, FV G v -> FV (FImp F G) v
| FV_Neg : forall F v, FV F v -> FV (FNeg F) v
| FV_All : forall F v, FV F (S v) -> FV (FAll F) v.
\end{minted}
\end{definition}

\begin{definition}
  \textit{Supstitucija} je svaka funkcija iz skupa \(\mathbb{N}\) u skup svih terma.
  Supstituciju \(\sigma\) možemo promatrati kao niz terma \(t_{0}, t_{1}, t_{2}, \ldots\).
  Tada je \textit{pomaknuta supstitucija}, s oznakom \(t \cdot \sigma\), supstitucija koja odgovara nizu \(t, t_{0}, t_{1}, t_{2}, \ldots\), za neki term \(t\).\\
  \noindent Domena supstitucije može se rekurzivno proširiti na skup svih terma i skup svih formula.
\begin{minted}{coq}
Fixpoint subst_term  (σ : var -> term) (t : term) : term :=
  match t with
  | var_term v => σ v
  | TFunc f args => TFunc f (V.map (subst_term σ) args)
  end.
\end{minted}
\begin{minted}{coq}
Fixpoint subst_formula
  (σ : var -> term Σ) (φ : formula )
  : formula  :=
  match φ return formula  with
  | FPred P args => FPred P (V.map (subst_term σ) args)
  | FIndPred P args => FIndPred P (V.map (subst_term σ) args)
  | FNeg ψ => FNeg (subst_formula σ ψ)
  | FImp ψ ξ => FImp (subst_formula σ ψ) (subst_formula σ ξ)
  | FAll ψ => FAll (subst_formula (up_term_term σ) ψ)
  end.
\end{minted}
  \noindent Ovdje funkcija \texttt{up\_term\_term} brine da supstitucija \(\sigma\) mijenja samo one varijable koje nisu vezane.
  \noindent Pišemo \(\varphi[\sigma]\) za primjenu supstitucije \(\sigma\) na formulu \(\varphi\).
  Često korištene supstitucije formula su
  supstitucija varijable \(x\) termom \(t\) u formuli \(\varphi\), s oznakom \(\varphi[t/x]\),
  te supstitucija svake varijable \(n\) u formuli \(\varphi\) varijablom \(n + 1\), s oznakom \(\varphi^{\uparrow}\).
  Iste notacije koristimo i za supstitucije na termima, listama terma i listama formula.
\end{definition}

Konačno, potrebno je definirati sintaksu za indukciju.
U Coqu su definicije induktivnih propozicija proizvoljne do na ograničenje pozitivnosti,
no radi jednostavnosti u \(\mathit{FOL_{ID}}\) su moguće samo
induktivne definicije s atomarnim formulama, a pišemo ih u stilu prirodne dedukcije:
\begin{prooftree}
  \AxiomC{\(  Q_{1}\mathbf{u}_{1}  \ldots   Q_{n}\mathbf{u}_{n}  \)}
  \AxiomC{\(  P_{1}\mathbf{v}_{1}  \ldots   P_{m}\mathbf{v}_{m}  \)}
  \BinaryInfC{\(P\mathbf{t}\)}
\end{prooftree}
\noindent Ovdje su \(Q_{1}, \ldots, Q_{n}\) obični predikatni simboli, \(P_{1}, \ldots, P_{m}\) i \(P\) su induktivni predikatni simboli,
a podebljani znakovi predstavljaju \(n\)-torke terma, gdje je \(n\) mjesnost odgovarajućeg predikata.

\begin{definition}
  Produkcija je uređena četvorka
  \begin{enumerate}
  \item liste parova običnih predikatnih simbola i \(n\)-torki terma odgovarajućih duljina,
  \item liste parova induktivnih predikatnih simbola i \(n\)-torki terma odgovarajućih duljina,
  \item induktivnog predikatnog simbola \(P\) mjesnosti \(m\) i
  \item \(m\)-torke terma.
  \end{enumerate}
\begin{minted}{coq}
Record production :=
  mkProd {
    preds : list {P : PredS Σ & vec (term Σ) (pred_ar P)};
    indpreds : list {P : IndPredS Σ & vec (term Σ) (indpred_ar P)};
    indcons : IndPredS Σ;
    indargs : vec (term Σ) (indpred_ar indcons);
  }.
\end{minted}
  Prvi i drugi član četvorke zovemo \textit{premisama}, a treći i četvrti \textit{konkluzijom}.
  U ostatku rada odabiremo neki podskup skupa svih produkcija koji zovemo
  \textit{skupom induktivnih definicija}, a označavamo s \(\Phi\).
\begin{minted}{coq}
Definition IndDefSet := production -> Prop.
\end{minted}
\end{definition}

U idućim primjerima definiramo produkcije za induktivne predikatne simbole u proširenoj Peanovoj signaturi.
\begin{example}\label{ex:productions-Nat}
  Za broj kažemo da je prirodan ako je \(0\) ili je sljedbenik nekog prirodnog broja.
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{(\texttt{PA\_prod\_N\_zero})}
    \UnaryInfC{\( \mathit{Nat}(o) \)}
  \end{prooftree}
\begin{minted}{coq}
Definition PA_prod_N_zero : @production Σ__PA.
  refine (@mkProd Σ__PA nil nil PA_Nat _).
  refine [(@TFunc Σ__PA PA_zero V.nil)].
Defined.
\end{minted}
  \begin{prooftree}
    \AxiomC{\( \mathit{Nat}(x) \)}
    \RightLabel{(\texttt{PA\_prod\_N\_succ})}
    \UnaryInfC{\( \mathit{Nat}(s(x)) \)}
  \end{prooftree}
\begin{minted}{coq}
Definition PA_prod_N_succ : @production Σ__PA.
  refine (@mkProd Σ__PA nil _ PA_Nat _).
  - refine (cons _ nil). exists PA_Nat; refine [(var_term 0)].
  - refine [(@TFunc Σ__PA PA_succ ([var_term 0]))].
Defined.
\end{minted}
\end{example}

\begin{remark}
  U primjeru~\ref{ex:productions-Nat} vidimo alternativni način definiranja u Coqu.
  Korisnik umjesto definiranja terma u Gallini ulazi u način dokazivanja te
  naredbom \texttt{refine} postepeno konstruira (\enquote{profinjuje}) rezultantni term.
\end{remark}

\begin{example}\label{ex:productions-Even-Odd}
  Za broj kažemo da je paran ako je \(0\) ili je sljedbenik nekog neparnog broja.
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{(\texttt{PA\_prod\_E\_zero})}
    \UnaryInfC{\( \mathit{Even}(o) \)}
  \end{prooftree}
\begin{minted}{coq}
Definition PA_prod_E_zero : @production Σ__PA.
  refine (@mkProd Σ__PA nil nil PA_Even _).
  refine ( [ @TFunc Σ__PA PA_zero ([]) ] ).
Defined.
\end{minted}
  \begin{prooftree}
    \AxiomC{\( \mathit{Odd}(x) \)}
    \RightLabel{(\texttt{PA\_prod\_E\_succ})}
    \UnaryInfC{\( \mathit{Even}(s(x)) \)}
  \end{prooftree}
\begin{minted}{coq}
Definition PA_prod_E_succ : @production Σ__PA.
  refine (@mkProd Σ__PA nil _ PA_Even _).
  - refine (cons _ nil). exists PA_Odd; refine ([var_term 0]).
  - refine [_].
    refine (@TFunc Σ__PA PA_succ _).
    refine [var_term 0].
Defined.
\end{minted}
  \noindent Za broj kažemo da je neparan ako je sljedbenik nekog parnog broja.
  \begin{prooftree}
    \AxiomC{\( \mathit{Even}(x) \)}
    \RightLabel{(\texttt{PA\_prod\_O\_succ})}
    \UnaryInfC{\( \mathit{Odd}(s(x)) \)}
  \end{prooftree}
\begin{minted}{coq}
Definition PA_prod_O_succ : @production Σ__PA.
  refine (@mkProd Σ__PA nil _ PA_Odd _).
  - refine (cons _ nil). exists PA_Even; refine ([var_term 0]).
  - refine [_].
    refine (@TFunc Σ__PA PA_succ _).
    refine ([var_term 0]).
Defined.
\end{minted}
  \noindent Skup prethodnih pet produkcija nazivamo
  skupom induktivnih definicija za proširenu Peanovu signaturu, s oznakom \(\Phi_{\mathit{PA}}\).
\begin{minted}{coq}
Inductive Φ__PA : @production Σ__PA -> Prop :=
| ID_N_zero : Φ__PA PA_prod_N_zero
| ID_N_succ : Φ__PA PA_prod_N_succ
| ID_E_zero : Φ__PA PA_prod_E_zero
| ID_E_succ : Φ__PA PA_prod_E_succ
| ID_O_succ : Φ__PA PA_prod_O_succ.
\end{minted}
\end{example}


\section{Semantika}\label{sec:semantika}
\begin{definition}
  \textit{Struktura prvog reda} (kratko: struktura) je uređena četvorka skupa \(M\) koji nazivamo \textit{nosačem}
  te interpretacija funkcijskih, običnih predikatnih i induktivnih predikatnih simbola.
  Funkcijski simboli mjesnosti \(n\) interpretiraju se kao \(n\)-mjesne funkcije, a predikatni simboli mjesnosti \(n\) kao \(n\)-mjesne relacije na nosaču.
  Koristit ćemo ime nosača kao sinonim za čitavu strukturu,
  a interpretacije označavati s \(f^{M}\) odnosno \(P^{M}\).
\begin{minted}{coq}
Structure structure := {
    domain :> Set;
    interpF (f : FuncS Σ) : vec domain (fun_ar f) -> domain;
    interpP (P : PredS Σ) : vec domain (pred_ar P) -> Prop;
    interpIP (P : IndPredS Σ) : vec domain (indpred_ar P) -> Prop;
  }.
\end{minted}
\end{definition}

\begin{example}\label{ex:structure}
  Prije no što možemo definirati strukturu za Peanovu aritmetiku s induktivnim predikatima,
  odnosno strukturu za signaturu \(\Sigma_{\mathit{PA}}\) i skup induktivnih definicija \(\Phi_{\mathit{PA}}\),
  potrebno je definirati odgovarajuće interpretacije induktivnih predikatnih simbola u Coqu, u skladu s primjerima~\ref{ex:productions-Nat} i~\ref{ex:productions-Even-Odd}.
\begin{minted}{coq}
Inductive NAT : nat -> Prop :=
| NO : NAT 0
| NS : forall n, NAT n -> NAT (S n).

Inductive EVEN : nat -> Prop :=
| EO : EVEN 0
| ES : forall n, ODD n -> EVEN (S n)
with ODD : nat -> Prop :=
| OS : forall n, EVEN n -> ODD (S n).
\end{minted}
  \noindent Ovdje su predikati \texttt{EVEN} i \texttt{ODD} definirani mehanizmom simultane rekurzije.\\
  \noindent Konačno možemo definirati strukturu \(M_{\mathit{PA}}\) s nosačem \(\mathbb{N}\) te uobičajenom interpretacijom
  funkcijskih i običnih predikatnih simbola. Induktivne predikatne simbole
  \(\mathit{Nat}\), \(\mathit{Even}\) i \(\mathit{Odd}\)
  interpretiramo redom Coqovim predikatima \texttt{NAT}, \texttt{EVEN} i \texttt{ODD}.
\begin{minted}{coq}
Definition M__PA : @structure Σ__PA.
  refine (Build_structure nat _ _ _).
  - intros []; cbn.
    + intros. exact 0.
    + intros n. exact (S (V.hd n)).
    + intros xy. exact (V.hd xy + V.hd (V.tl xy)).
    + intros xy. exact (V.hd xy * V.hd (V.tl xy)).
  - intros []. cbn. intros args.
    exact (V.hd args = V.hd (V.tl args)).
  - intros []; cbn; intros args.
    + exact (NAT (V.hd args)).
    + exact (EVEN (V.hd args)).
    + exact (ODD (V.hd args)).
Defined.
\end{minted}
\end{example}


\begin{definition}
  Neka je \(M\) proizvoljna struktura. \textit{Okolina} \(\rho\) za \(M\) je proizvoljna funkcija iz skupa prirodnih brojeva u nosač strukture.
\begin{minted}{coq}
Definition env := var -> M.
\end{minted}
  \noindent Okolina se može interpretirati kao niz \(d_{0}, d_{1}, d_{2}, \ldots\). Tada je \textit{pomaknuta okolina}, s oznakom \(d \cdot \rho\),
  niz \(d, d_{0}, d_{1}, d_{2}, \ldots\) za neki \(d \in M\).
  \noindent Proširenje domene okoline \(\rho\) na skup svih terma zovemo \textit{evaluacijom}.
\begin{minted}{coq}
Fixpoint eval (ρ : env) (t : term Σ) : M :=
  match t with
  | var_term x => ρ x
  | TFunc f args => interpF f (V.map (eval ρ) args)
  end.
\end{minted}
  Pišemo \(t^{\rho}\) za evaluaciju terma \(t\) u okolini \(\rho\).
  Istu notaciju koristimo i za evaluaciju \(n\)-torki terma.
\end{definition}

\begin{definition}
  Neka je \(M\) proizvoljna struktura te \(\rho\) okolina za \(M\).
  \textit{Istinitost} formule \(\varphi\) u okolini \(\rho\), s oznakom \(\rho \vDash \varphi\),
  definiramo rekurzivno na način:
  \begin{enumerate}
  \item ako je \(P\) (obični ili induktivni) predikatni simbol mjesnosti \(n\)
    te su \(u_{1}, \ldots, u_{n}\) termi,
    onda vrijedi \(\rho \vDash P(u_{1}, \ldots, u_{n})\) ako i samo ako vrijedi \(P^{M}(\rho(u_{1}), \ldots, \rho(u_{n}))\),
  \item vrijedi \(\rho \vDash \neg \varphi \) ako i samo ako ne vrijedi \(\rho \vDash \varphi\) (što još pišemo \(\rho \not \vDash \varphi\)),
  \item vrijedi \(\rho \vDash \varphi \rightarrow \psi \) ako i samo ako vrijedi \(\rho \not \vDash \varphi\) ili \(\rho \vDash \psi\) i
  \item vrijedi \(\rho \vDash \forall \varphi\) ako i samo ako za sve \(d \in M\) vrijedi \(d \cdot \rho \vDash \varphi\)
  \end{enumerate}
\begin{minted}{coq}
Fixpoint Sat (ρ : env M) (F : formula Σ) : Prop :=
  match F with
    | FPred P args => interpP P (V.map (eval ρ) args)
    | FIndPred P args => interpIP P (V.map (eval ρ) args)
    | FNeg G => ~ Sat ρ G
    | FImp F G => Sat ρ F -> Sat ρ G
    | FAll G => forall d, Sat (d .: ρ) G
  end.
\end{minted}
\end{definition}

\begin{example}
  Formula \(\forall x, N(x) \rightarrow E(x) \lor O(x)\) je istinita u strukturi \(M_{\mathit{PA}}\)
  bez obzira na njenu okolinu.
\begin{minted}{coq}
Lemma every_nat_is_even_or_odd_Sat :
  forall (ρ : env M__PA), ρ ⊨ every_nat_is_even_or_odd.
\end{minted}
\end{example}

\begin{lemma}
  Neka su \(\varphi\), \(\sigma\), \(M\) i \(\rho\) redom
  proizvoljna formula, supstitucija, struktura i okolina za \(M\).
  Tada vrijedi \(\rho \vDash \varphi[\sigma]\) ako i samo ako vrijedi \( (t \mapsto t^{\rho}) \, \circ \, \sigma \vDash \varphi\).
\begin{minted}{coq}
Lemma strong_form_subst_sanity2 :
  forall (φ : formula Σ) (σ : var -> term Σ)
      (M : structure Σ) (ρ : env M),
      ρ ⊨ (subst_formula σ φ) <-> (σ >> eval ρ) ⊨ φ.
\end{minted}
  \noindent Kompoziciju supstitucije \(\sigma\) i evaluacije \(t \mapsto t^{\rho}\)
  možemo nazvati \textit{semantičkom} supstitucijom
  jer prvo provodi \textit{sintaktičku} supstituciju \(\sigma\) nakon čega provodi evaluaciju.
  Tada možemo neformalno reći da sintaktička i semantička supstitucija
  komutiraju pod relacijom istinitosti.
\end{lemma}

\section{Standardni modeli}\label{sec:standardni-modeli}
Želimo ograničiti semantička razmatranja na samo one strukture koje \enquote{imaju smisla} za induktivne predikate.
Prisjetimo se, predikatni simbol \(P\) mjesnosti \(n\) interpretira se na strukturi \(M\)  podskupom skupa \(M^{n}\).
Indukciju smatramo dokazivanjem \textup{u razinama} pa ima smisla promatrati \textit{razine interpretacije} induktivnog predikata,
gdje je nulta razina prazan skup,
a svaku iduću razinu konstruiramo pomoću produkcija induktivnog skupa definicija i prethodnih razina.
Tako je prva razina onaj podskup kojeg možemo dobiti najviše jednom \enquote{primjenom produkcija},
druga je razina onaj podskup kojeg možemo dobiti pomoću najviše dviju primjena produkcija, i tako dalje.
Na taj se način, korak po korak, gradi \textit{smislena} interpretacija induktivnih predikata.
Napominjemo da se zbog mogućih međuovisnosti induktivnih predikata razine interpretacije definiraju simultano.
Ovaj odjeljak posvećujemo formalizaciji ovih pojmova.

\begin{definition}
  Neka je \(M\) proizvoljna struktura te neka je \(pr\) proizvoljna produkcija induktivnog skupa definicija \(\Phi\), primjerice:
  \begin{prooftree}
  \AxiomC{\(  Q_{1}\mathbf{u}_{1}  \ldots   Q_{n}\mathbf{u}_{n}  \)}
  \AxiomC{\(  P_{1}\mathbf{v}_{1}  \ldots   P_{m}\mathbf{v}_{m}  \)}
  \BinaryInfC{\(P\mathbf{t}\)}
  \end{prooftree}
\noindent Neka je \(f\) proizvoljna interpretacija induktivnih predikatnih simbola.
Tada definiramo \(\varphi_{pr}(f)\) kao skup svih \(|P|\)-torki \(\mathbf{d}\) elemenata nosača \(M\) za koje postoji okolina \(\rho\) za \(M\) takva da:
\begin{itemize}
\item za sve \( i \in \{ 1, \ldots, n \} \) vrijedi \( \mathbf{u}_{i}^{\rho} \in Q_{i}^{M} \), % TODO uvesti ovu notaciju za u
\item za sve \( j \in \{ 1, \ldots, m \} \) vrijedi \( \mathbf{v_{i}^{\rho}} \in f(P_{i}) \) i
\item \(\mathbf{d} = \mathbf{t}^{\rho}\).
\end{itemize}
\begin{minted}{coq}
Definition φ_pr
  (pr : production)
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
  (ds : vec D (indpred_ar (indcons pr)))
  : Prop :=
      exists (ρ : env M),
      (forall Q us, List.In (Q; us) (preds pr) ->
               interpP Q (V.map (eval ρ) us)) /\
        (forall P ts, List.In (P; ts) (indpreds pr) ->
                  args P (V.map (eval ρ) ts)) /\
        ds = V.map (eval ρ) (indargs pr).
\end{minted}
\noindent Operator \(\varphi_{pr}\) je formalizacija ideje primjene produkcije.
Nadalje, potrebno je definirati operator koji će uzeti u obzir \textit{sve} produkcije koje se odnose na \(P\).
Definiramo \(\varphi_{P}(f)\) kao uniju svih \(\varphi_{pr^{\prime}}(f)\)
gdje je \(pr^{\prime}\) produkcija u kojoj se \(P\) javlja u konkluziji.
\begin{minted}{coq}
Definition φ_P
  (P : IndPredS Σ)
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
  : vec D (indpred_ar P) -> Prop.
  refine (fun ds => _).
  refine (@ex production (fun pr => _)).
  refine (@ex (P = indcons pr /\ Φ pr) (fun '(conj Heq HΦ) => _)).
  rewrite Heq in ds.
  exact (φ_pr pr args ds).
Defined.
\end{minted}
\noindent Konačno, definiramo \textit{operator skupa definicija} \(\varphi_{\Phi}\) kao preslikavanje
koje svakom induktivnom predikatnom simbolu \(P\) pridružuje skup \(\varphi_{P}(f)\).
\begin{minted}{coq}
Definition φ_Φ
  (args : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop)
    : forall P : IndPredS Σ, vec D (indpred_ar P) -> Prop :=
    fun P => φ_P P args.
\end{minted}
\noindent Operator \(\varphi_{\Phi}\) omogućuje simultanu primjenu produkcija.
\end{definition}

\begin{remark}\label{remark:phi-phi-notation}
  Kako je funkcija \(f\) bila uvedena na samom početku prethodne definicije,
  u stvari definicija operatora \(\varphi_{\Phi}\) glasi
  \(
    \varphi_{\Phi}(f)(P) \coloneq \varphi_{P}(f)
  \).
\end{remark}

\begin{example}\label{ex:operator-phi-phi-PA}
  Ilustrirajmo operator \(\varphi_{\Phi}\) na strukturi \(M_{\mathit{PA}}\) i
  skupu induktivnih definicija \(\Phi_{\mathit{PA}}\).
  Prisjetimo se, u proširenoj Peanovoj signaturi imamo tri induktivna predikatna simbola;
  \(\mathit{Nat}\), \(\mathit{Even}\) i \(\mathit{Odd}\), svaki od kojih je jednomjesan.
  Dakle, domena i kodomena operatora \(\varphi_{\Phi}\) u ovom primjeru je skup \(\mathcal{P(\mathbb{N})}^{3}\),
  gdje prva, druga i treća projekcija odgovaraju redom interpretacijama predikata
  \(\mathit{Nat}\), \(\mathit{Even}\) i \(\mathit{Odd}\). Nadalje, vrijedi:
  \[
    \varphi_{\Phi_{\mathit{PA}}, M_{\mathit{PA}}}(N, E, O) =
    ( \{ 0 \} \cup \{ n + 1 \mid n \in N \},
    \{ 0 \} \cup \{ o + 1 \mid o \in O \},
    \{ e + 1 \mid e \in E \} ).
  \]
  \noindent Prema notaciji u prethodnoj napomeni,
  funkcija \(f\) je ovdje trojka \((N, E, O)\),
  a indeksiranje induktivnim predikatnim simbolom odgovara navedenim projekcijama.
\end{example}

\begin{proposition}
  Operator \(\varphi_{\Phi}\) je monoton.
\begin{minted}{coq}
Proposition φ_Φ_monotone :
  forall (f g : forall P, vec D (indpred_ar P) -> Prop),
    (forall P v, f P v -> g P v) ->
    (forall P v, φ_Φ f P v -> φ_Φ g P v).
\end{minted}
\end{proposition}

\begin{definition}
  Neka je \(M\) proizvoljna struktura.
  Definiramo aproksimaciju skupa induktivnih definicija \(\Phi\) razine \(\alpha \in \mathbb{N}\), u oznaci \(\varphi_{\Phi}^{\alpha}\), rekurzivno na način:
  \begin{enumerate}
  \item \( \varphi_{\Phi}^{0}(P) \coloneq \varnothing \) i
  \item \( \varphi_{\Phi}^{\alpha + 1} \coloneq \varphi_{\Phi}(\varphi_{\Phi}^{\alpha}) \).
  \end{enumerate}
\begin{minted}{coq}
Fixpoint φ_Φ_n P (α : nat) (v : vec M (indpred_ar P)) : Prop :=
  match α with
  | 0 => False
  | S α => @φ_Φ Σ M Φ (fun P => φ_Φ_n P α) P v
  end.
\end{minted}
  \noindent Tada je \textit{aproksimant} induktivnog predikatnog simbola \(P\) razine \(\alpha\) upravo \(\varphi_{\Phi}^{\alpha}(P)\).
\begin{minted}{coq}
Definition approximant_of (P : IndPredS Σ)
  : nat -> vec M (indpred_ar P) -> Prop :=
  φ_Φ_n P.
\end{minted}
\end{definition}

\begin{remark}
  Brotherston je definirao aproksimaciju razine \(\alpha\) za pojedini induktivni predikatni simbol
  kao uniju aproksimacija svih nižih razina.
  Takva je definicija ekvivalentna našoj.
\end{remark}

\begin{lemma}\label{lemma:ekvivalentnost-definicija-aproksimacija}
  Za svaki prirodni broj \(\alpha\) i induktivni predikatni simbol \(P\) vrijedi
  \[
    \varphi_{\Phi}^{\alpha}(P) = \bigcup_{\beta < \alpha} \varphi_{\Phi}^{\beta}(P).
  \]
\begin{minted}{coq}
Lemma approximant_characterization : forall α P v,
      φ_Φ_n P α v <-> exists β,
                      β < α /\ @φ_Φ Σ M Φ (fun P => φ_Φ_n P β) P v.
\end{minted}
\end{lemma}

\begin{example}
  Za svaki prirodan broj \(\alpha\), a u skladu s primjerom~\ref{ex:operator-phi-phi-PA},
  aproksimant razine \(\alpha\) induktivnog predikatnog simbola \(\mathit{Nat}\)
  je skup svih prirodnih brojeva strogo manjih od \(\alpha\), odnosno vrijedi:
  \[
    \varphi_{\Phi_{\mathit{PA}}, M_{\mathit{PA}}}^{\alpha}(\mathit{Nat}) = \{ 0, 1, \ldots, \alpha - 1 \}.
  \]
\begin{minted}{coq}
Lemma approximants_of_PA_Nat : forall α n,
    @approximant_of Σ__PA M__PA Φ__PA PA_Nat α ([n])
    <-> n < α.
\end{minted}
\end{example}

\begin{definition}
  \textit{Aproksimacija razine} \(\omega\), u oznaci \(\varphi_{\Phi}^{\omega}\), je za svaki pojedini predikatni simbol
  unija aproksimacija razina manjih od \(\omega\).
\begin{minted}{coq}
Definition φ_Φ_ω P v := exists α, φ_Φ_n P α v.
\end{minted}
\end{definition}

\begin{example}
  Aproksimant razine \(\omega\) induktivnog predikatnog simbola \(\mathit{Nat}\)
  je cijeli skup prirodnih brojeva \(\mathbb{N}\).
\begin{minted}{coq}
Lemma NAT_φ_Φ_ω: forall (n : nat), @φ_Φ_ω Σ__PA M__PA Φ__PA PA_Nat ([n]).
\end{minted}
\end{example}

\begin{lemma}\label{lemma:omega-least-prefixed}
  Aproksimacija razine \(\omega\) je najmanji skup sa svojstvom \(\varphi_{\Phi}(\varphi_{\Phi}^{\omega}) \subseteq \varphi_{\Phi}^{\omega}\).
\begin{minted}{coq}
Lemma ω_prefixed : forall P v, @φ_Φ Σ M Φ φ_Φ_ω P v -> φ_Φ_ω P v.
Lemma ω_least : forall args,
                (forall P v, @φ_Φ Σ M Φ args P v -> args P v) ->
                forall P v, φ_Φ_ω P v -> args P v.
\end{minted}
\end{lemma}

\begin{definition}
  Kažemo da je struktura \(M\) \textit{standardni model} za \(\Phi\) ako
  interpretira svaki induktivni predikatni simbol njegovim aproksimantom razine \(\omega\).
\begin{minted}{coq}
Definition standard_model
  (Σ : signature) (Φ: @IndDefSet Σ) (M : structure Σ) : Prop :=
  forall (P : IndPredS Σ) ts, interpIP P ts <-> @φ_Φ_ω Σ M Φ P ts.
\end{minted}
\end{definition}
\noindent Prema lemi~\ref{lemma:omega-least-prefixed}, standardni model je
najmanja struktura koja ima smisla za zadani skup induktivnih definicija.

\begin{proposition}
  Struktura \(M_{\mathit{PA}}\) je standardni model za skup induktivnih definicija \(\Phi_{\mathit{PA}}\).
\begin{minted}{coq}
Lemma standard_model__PA : @standard_model Σ__PA Φ__PA M__PA.
\end{minted}
\end{proposition}


\section{Sistem sekvenata s induktivnim definicijama}\label{sec:sistem-sekvenata}
Cilj je ovog odjeljka definirati dokazni sustav \(\mathit{LKID}\) za logiku \(\mathit{FOL_{ID}}\).
Ovaj dokazni sustav temelji se na Gentzenovu računu sekvenata, a proširen je lijevim i desnim pravilima za indukciju.
Prije no što definiramo \(\mathit{LKID}\), potrebno je definirati pojam sekvente i međusobne zavisnosti induktivnih predikata.

\begin{definition}
  Neka su \(\Gamma\) i \(\Delta\) proizvoljne liste formula. Tada je \textit{sekventa} uređeni par \((\Gamma,\Delta)\), a označavamo ju s \(\Gamma \vdash \Delta\).
\begin{minted}{coq}
Inductive sequent : Set :=
| mkSeq (Γ Δ : list (formula Σ)).
\end{minted}
\end{definition}
\noindent Sekventom \(\Gamma \vdash \Delta\) konceptualno tvrdimo da istinitost \textit{svake}
tvrdnje u \(\Gamma\) povlači istinitost \textit{neke} tvrdnje u \(\Delta\).
Kažemo da je sekventa \(\Gamma \vdash \Delta\) \textit{dokaziva}, ili da iz \(\Gamma\) postoji izvod za \(\Delta\), ako u sustavu \(\mathit{LKID}\) postoji \textit{dokaz} za \(\Gamma \vdash \Delta\). Pojam dokaza ćemo precizirati kasnije.

\begin{definition}
  Neka su \(P_{i}\) i \(P_{j}\) proizvoljni induktivni predikatni simboli.
  Kažemo da je simbol \(P_{i}\) u relaciji \(\mathit{Prem}\) sa simbolom \(P_{j}\)
  ako postoji produkcija u skupu induktivnih definicija \(\Phi\) takva da
  se simbol \(P_{i}\) javlja u njenoj konkluziji te
  se simbol \(P_{j}\) javlja u njenim premisama.
\begin{minted}{coq}
Definition Prem (Pi Pj : IndPredS Σ) :=
  exists pr, Φ pr /\
             indcons pr = Pi /\
             exists ts, List.In (Pj; ts) (indpreds pr).
\end{minted}
\end{definition}

\begin{definition}
  Definiramo relaciju \(\mathit{Prem}^{\ast}\) kao refleksivno i tranzitivno zatvorenje relacije \(\mathit{Prem}\) na skupu induktivnih predikatnih simbola.
\begin{minted}{coq}
Definition Prem_star := clos_refl_trans (IndPredS Σ) Prem.
\end{minted}
  \noindent Za induktivne predikatne simbole \(P\) i \(Q\) kažemo da su
  \textit{međusobno zavisni} ako vrijedi \(\mathit{Prem}^{\ast}(P, Q)\) i \(\mathit{Prem}^{\ast}(Q, P)\).
\begin{minted}{coq}
Definition mutually_dependent (P Q : IndredS Σ) :=
  Prem_star P Q /\ Prem_star Q P.
\end{minted}
  \noindent Za međusobno zavisne induktivne predikatne simbole kažemo još da su
  definirani simultanom rekurzijom.
  Coqovi predikati \texttt{EVEN} i \texttt{ODD} iz primjera~\ref{ex:structure}
  definirani su simultanom rekurzijom.
\end{definition}

\begin{example}
  U skupu induktivnih definicija \(\Phi_{\mathit{PA}}\),
  induktivni predikatni simboli \(\mathit{Even}\) i \(\mathit{Odd}\)
  su međusobno zavisni.
\begin{minted}{coq}
Example mut_dep_E_O :
  @mutually_dependent Σ__PA Φ__PA PA_Even PA_Odd.
\end{minted}
  \noindent S druge strane, induktivni predikatni simboli \(\mathit{Nat}\) i \(\mathit{Even}\)
  \textit{nisu} međusobno zavisni.
\begin{minted}{coq}
Example not_mut_dep_N_E :
  ~ @mutually_dependent Σ__PA Φ__PA PA_Nat PA_Even.
\end{minted}
\end{example}

\begin{lemma}
  Međusobna zavisnost je relacija ekvivalencije na skupu induktivnih predikatnih simbola.
\begin{minted}{coq}
Lemma mutually_dependent_equiv : equiv (IndPredS Σ) mutually_dependent.
\end{minted}
\end{lemma}

Sustav \(\mathit{LKID}\) sastoji se od četiri vrste pravila izvoda:
strukturalna, propozicijska, pravila za kvantifikatore i pravila za induktivne definicije.
Navest ćemo ih tim redom, a definirati kroz više blokova Coq koda.
Napominjemo da se sustav \(\mathit{LKID}\) razlikuje od Gentzenova sustava \(\mathit{LK}\)
na nekoliko mjesta, a zbog implementacijskih detalja te induktivnih definicija.
Za neko pravilo izvoda kažemo da je \textit{dopustivo} ako nije u definiciji sustava \(\mathit{LKID}\),
ali je iz originalnih pravila izvedivo.
\begin{minted}{coq}
Inductive LKID : sequent -> Prop := 
\end{minted}

\textbf{Strukturalna} su \textbf{pravila} prikazana na slici~\ref{fig:lkid-structural}, a služe baratanju strukturom sekvente.
Iako je sekventa implementirana kao par listi formula, te liste se ponašaju kao skupovi u strukturalnim pravilima
jer za provjeru pripadnosti koristimo Coqov predikat \texttt{In}.
Posljedično, pravilo slabljenja \(\mathit{Wk}\) sa sobom povlači pravila permutacije i kontrakcije.
\begin{figure}[!htb]
  \centering

  \begin{prooftree}
    \AxiomC{\(\Gamma \cap \Delta \not = \varnothing \)}
    \RightLabel{\( \mathit{ (Ax) } \)}
    \UnaryInfC{\( \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\(\Gamma^{\prime} \vdash \Delta^{\prime}\)}
    \AxiomC{\(\Gamma^{\prime} \subseteq \Gamma\)}
    \AxiomC{\(\Delta^{\prime} \subseteq \Delta\)}
    \RightLabel{\( \mathit{ (Wk) } \)}
    \TrinaryInfC{\(\Gamma \subseteq \Delta\)}
  \end{prooftree}
  
  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta\)}
    \AxiomC{\( \varphi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (Cut) } \)}
    \BinaryInfC{\( \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (Subst) } \)}
    \UnaryInfC{\( \Gamma[\sigma] \vdash \Delta[\sigma] \)}
  \end{prooftree}
  
  \caption{Strukturalna pravila sustava \(\mathit{LKID}\).}\label{fig:lkid-structural}
\end{figure}
\begin{minted}[firstnumber=last]{coq}
(* Structural rules. *)
| Ax : forall Γ Δ φ, In φ Γ -> In φ Δ -> LKID (Γ ⊢ Δ)
| Wk : forall Γ' Δ' Γ Δ,
    Γ' ⊆ Γ ->
    Δ' ⊆ Δ ->
    LKID (Γ' ⊢ Δ') ->
    LKID (Γ ⊢ Δ)
| Cut : forall Γ Δ φ,
    LKID (Γ ⊢ φ :: Δ) ->
    LKID (φ :: Γ ⊢ Δ) ->
    LKID (Γ ⊢ Δ)
| Subst : forall Γ Δ,
    LKID (Γ ⊢ Δ) ->
    forall σ, LKID (map (subst_formula σ) Γ ⊢ map (subst_formula σ) Δ)
\end{minted}

\begin{example}
  Prošireno pravilo aksioma je dopustivo.
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\( \mathit{ (AxExtended) } \)}
    \UnaryInfC{\( \varphi, \Gamma \vdash \varphi, \Delta \)}
  \end{prooftree}
\begin{minted}[linenos=false]{coq}
Lemma AxExtended : forall Γ Δ φ, LKID (φ :: Γ ⊢ φ :: Δ).
\end{minted}
  \noindent Pravilo permutacije je dopustivo.
  \begin{prooftree}
    \AxiomC{\( \Gamma^{\prime} \vdash \Delta^{\prime} \)}
    \AxiomC{\( \Gamma^{\prime} \sim \Gamma \)}
    \AxiomC{\( \Delta^{\prime} \sim \Delta \)}
    \RightLabel{\(\mathit{ (Perm) }\)}
    \TrinaryInfC{\( \Gamma \vdash \Delta \)}
  \end{prooftree}
  \noindent Ovdje znakom \(\sim\) označujemo relaciju permutacije na listama.
\begin{minted}[linenos=false]{coq}
Lemma Perm : forall Γ' Δ' Γ Δ,
    Permutation Γ' Γ ->
    Permutation Δ' Δ ->
    LKID (Γ' ⊢ Δ') ->
    LKID (Γ ⊢ Δ).
\end{minted}
\end{example}


\textbf{Propozicijska} su \textbf{pravila} prikazana na slici~\ref{fig:lkid-propositional}, a služe rasuđivanju s implikacijama i negacijama.
Ova su pravila identična u sustavima \(\mathit{LK}\) i \(\mathit{LKID}\).
\begin{figure}[!htb]
  \centering
  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta \)}
    \RightLabel{\( \mathit{ (NegL) } \)}
    \UnaryInfC{\( \neg \varphi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (NegR) } \)}
    \UnaryInfC{\( \Gamma \vdash \neg \varphi, \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta \)}
    \AxiomC{\( \psi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (ImpL) } \)}
    \BinaryInfC{\( \varphi \rightarrow \psi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma \vdash \psi, \Delta \)}
    \RightLabel{\( \mathit{ (ImpR) } \)}
    \UnaryInfC{\( \Gamma \vdash \varphi \rightarrow \psi, \Delta \)}
  \end{prooftree}
  
  \caption{Propozicijska pravila sustava \(\mathit{LKID}\).}\label{fig:lkid-propositional}
\end{figure}
\begin{minted}[firstnumber=16]{coq}
(* Propositional rules. *)
| NegL : forall Γ Δ φ, LKID (Γ ⊢ φ :: Δ) -> LKID (FNeg φ :: Γ ⊢ Δ)
| NegR : forall Γ Δ φ, LKID (φ :: Γ ⊢ Δ) -> LKID (Γ ⊢ FNeg φ :: Δ)
| ImpL : forall Γ Δ φ ψ,
    LKID (Γ ⊢ φ :: Δ) -> LKID (ψ :: Γ ⊢ Δ) ->
    LKID (FImp φ ψ :: Γ ⊢ Δ)
| ImpR : forall Γ Δ φ ψ,
    LKID (φ :: Γ ⊢ ψ :: Δ) -> LKID (Γ ⊢ (FImp φ ψ) :: Δ)
\end{minted}

\begin{example}
  Desno pravilo za konjunkciju je dopustivo.
  \begin{prooftree}
    \AxiomC{\( \Gamma \vdash \varphi, \Delta \)}
    \AxiomC{\( \Gamma \vdash \psi, \Delta \)}
    \RightLabel{\( \mathit{ (AndR) } \)}
    \BinaryInfC{\( \Gamma \vdash \varphi \land \psi, \Delta \)}
  \end{prooftree}
\begin{minted}[linenos=false]{coq}
Lemma AndR : forall Γ Δ φ ψ,
    LKID (Γ ⊢ φ :: Δ) -> LKID (Γ ⊢ ψ :: Δ) ->
    LKID (Γ ⊢ FAnd φ ψ :: Δ).
\end{minted}
  \noindent Lijevo pravilo za disjunkciju je dopustivo.
  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma \vdash \Delta \)}
    \AxiomC{\( \psi, \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (OrL) } \)}
    \BinaryInfC{\( \varphi \lor \psi, \Gamma \vdash \Delta \)}
  \end{prooftree}
\begin{minted}[linenos=false]{coq}
Lemma OrL : forall Γ Δ φ ψ,
    LKID (φ :: Γ ⊢ Δ) -> LKID (ψ :: Γ ⊢ Δ) ->
    LKID (FOr φ ψ :: Γ ⊢ Δ).
\end{minted}
\end{example}

\textbf{Pravila za kvantifikatore} prikazana su na slici~\ref{fig:lkid-quantificational}, a odnose se na univerzalnu kvantifikaciju.
Ova se pravila razlikuju od analognih u sustavu \(\mathit{LK}\) zbog korištenja de Bruijnovih indeksa kod kvantifikacije.
U lijevom pravilu koristimo supstituciju \(t \cdot \sigma_{\mathit{id}}\) u formuli \(\varphi\), gdje je \(\sigma_{\mathit{id}}\) supstitucija identiteta,
kako bismo iskazali da se term \(t\) javlja na mjestu neke varijable \(x\).
Za desno pravilo, primijetimo da se varijabla \(0\) ne javlja u listama formula \(\Gamma^{\uparrow}\) i \(\Delta^{\uparrow}\) zbog pomicanja.
Kako implicitno kvantificiramo po varijabli \(0\), a  ona se javlja
(eventualno) samo u formuli \(\varphi\), smijemo univerzalno kvantificirati formulu \(\varphi\).

\begin{figure}[!htb]
  \centering
  \begin{prooftree}
    \AxiomC{\( \varphi[t \cdot \sigma_{\mathit{id}}], \Gamma \vdash \Delta \)}
    \RightLabel{\( \mathit{ (AllL) } \)}
    \UnaryInfC{\( \forall\varphi, \Gamma \vdash \Delta \)}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{\( \Gamma^{\uparrow} \vdash \varphi, \Delta^{\uparrow}\)}
    \RightLabel{\( \mathit{ (AllR) } \)}
    \UnaryInfC{\( \Gamma \vdash \forall\varphi, \Delta \)}
  \end{prooftree}
  \caption{Pravila za kvantifikatore sustava \(\mathit{LKID}\).}\label{fig:lkid-quantificational}
\end{figure}
\begin{minted}[firstnumber=24]{coq}
(* Quantifier rules. *)
| AllL : forall Γ Δ φ t,
    LKID (subst_formula (t .: ids) φ :: Γ ⊢ Δ) -> 
    LKID (FAll φ :: Γ ⊢ Δ)
| AllR : forall Γ Δ φ,
    LKID (shift_formulas Γ ⊢ φ :: shift_formulas Δ) ->
    LKID (Γ ⊢ (FAll φ) :: Δ)
\end{minted}

\begin{example}
  Lijevo pravilo za egzistencijalnu kvantifikaciju je dopustivo.
  \begin{prooftree}
    \AxiomC{\( \varphi, \Gamma^{\uparrow} \vdash \Delta^{\uparrow} \)}
    \RightLabel{\( \mathit{ (ExistL) } \)}
    \UnaryInfC{\( \exists\varphi, \Gamma \vdash \Delta\)}
  \end{prooftree}
\begin{minted}[linenos=false]{coq}
Lemma ExistL : forall Γ Δ φ,
    LKID (φ :: shift_formulas Γ ⊢ shift_formulas Δ) ->
    LKID (FExist φ :: Γ ⊢ Δ).
\end{minted}
\end{example}

\begin{minted}[firstnumber=31]{coq}
  | IndL : forall Γ Δ (Pj : IndPredS Σ) (u : vec (term Σ) (indpred_ar Pj))
             (z_i : forall P, vec var (indpred_ar P)) (* dodati pretpostavku forall P, NoDup (z_i P)? *)
             (G_i : IndPredS Σ -> formula Σ)
             (HG2 : forall Pi, ~mutually_dependent Pi Pj -> G_i Pi = FIndPred Pi (V.map var_term (z_i Pi))),
      let maxΓ := max_fold (map some_var_not_in_formula Γ) in
      let maxΔ := max_fold (map some_var_not_in_formula Δ) in
      let maxP := some_var_not_in_formula (FIndPred Pj u) in
      let shift_factor := max maxP (max maxΓ maxΔ) in
      let Fj := subst_formula (finite_subst (z_i Pj) u) (G_i Pj) in
      let minor_premises :=
        (forall pr (Hdep : mutually_dependent (indcons pr) Pj),
            let Qs := shift_formulas_by shift_factor (FPreds_from_preds (preds pr)) in
            let Gs := map (fun '(P; args) =>
                             let shifted_args := V.map (shift_term_by shift_factor) args in
                             let σ := finite_subst (z_i P) (shifted_args) in
                             let G := G_i P in
                             subst_formula σ G)
                        (indpreds pr) in
            let Pi := indcons pr in
            let ty := V.map (shift_term_by shift_factor) (indargs pr) in
            let Fi := subst_formula (finite_subst (z_i Pi) ty) (G_i Pi) in
            LKID (Qs ++ Gs ++ Γ ⊢ Fi :: Δ))
      in
      minor_premises ->
      LKID (Fj :: Γ ⊢ Δ) ->
      LKID (FIndPred Pj u :: Γ ⊢ Δ)
  | IndR : forall Γ Δ pr σ,
      Φ pr ->
      (forall Q us, In (Q; us) (preds pr) ->
               LKID (Γ ⊢ (FPred Q (V.map (subst_term σ) us) :: Δ))) ->
      (forall P ts, In (P; ts) (indpreds pr) ->
               LKID (Γ ⊢ (FIndPred P (V.map (subst_term σ) ts) :: Δ))) ->
      LKID ( Γ ⊢ FIndPred (indcons pr) (V.map (subst_term σ) (indargs pr)) :: Δ).
\end{minted}



\section{Adekvatnost}\label{sec:adekvatnost}
Lokalne adekvatnosti za pravila izvoda. Glavni teorem.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
