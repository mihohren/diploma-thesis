\chapter{Logika prvog reda s induktivnim definicijama}\label{cha:logika-prvog-reda}
U ovom poglavlju predstavljamo glavne rezultate diplomskog rada koji uključuju formalizaciju
logike prvog reda s induktivnim definicijama \(\mathit{FOL_{ID}}\)
te dokaznog sustava \(\mathit{LKID}\), koje je prvi uveo Brotherston~\cite{brotherston2005}.
Definicije, leme i dokazi u ovom poglavlju preuzete su iz Brotherstonove disertacije~\cite{brotherstonphd}.

Prvo ćemo definirati sintaksu i semantiku logike \(\mathit{FOL_{ID}}\),
nakon čega ćemo definirati njene standardne modele.
Zatim ćemo prikazati dokazni sustav \(\mathit{LKID}\) te konačno dokazati adekvatnost
sustava \(LKID\) s obzirom na standardnu semantiku,
što je ujedno i glavni rezultat ovog diplomskog rada.

Svaka definicija i lema u ovom poglavlju bit će popraćena svojim pandanom u Coqu.
Jedan je od ciljeva diplomskog rada prikazati primjene Coqa u matematici,
zbog čega leme nećemo dokazivati ``na papiru'',
već se dokaz svake leme može pronaći na GitHub repozitoriju rada.\footnote{TODO: REPO LINK}
Zainteresiranom čitatelju predlažemo interaktivni prolazak kroz dokaze lema.

\section{Sintaksa}\label{sec:sintaksa}
Kao i u svakom izlaganju logike, na početku je potrebno definirati sintaksu.
\begin{definition}\label{def:signatura}
  \textit{Jezik prvog reda s induktivnim predikatima} (kratko: \textbf{signatura}), u oznaci \(\Sigma\),
  je skup simbola od kojih razlikujemo \textit{funkcijske} simbole, \textit{obične predikatne} simbole
  i \textit{induktivne predikatne} simbole.
  Svaki simbol signature ima pripadajuću mjesnost.
  Funkcijski simboli mjesnosti nula nazivaju se \textit{konstante},
  a predikatni simboli mjesnosti nula nazivaju se \textit{propozicije}.
  \begin{minted}{coq}
Structure signature := {
  FuncS : Type;
  fun_ar : FuncS -> nat;
  PredS : Type;
  pred_ar : PredS -> nat;
  IndPredS : Type;
  indpred_ar : IndPredS -> nat
}.
  \end{minted}
\end{definition}

\noindent Već smo vidjeli da se propozicije, odnosno skupovi, u Coqu mogu reprezentirati tipovima.
Tako i ovdje skupove funkcijskih, običnih predikatnih i induktivnih predikatnih simbola prikazujemo tipovima.
Mjesnost simbola reprezentiramo kao funkciju iz skupa odgovarajućih simbola u skup \(\mathbb{N}\).

\misao{Stavljam i primjere? Tu je dobar primjer \(\Sigma_{PA}\).}

\noindent U ostatku poglavlja promatramo jednu proizvoljnu, ali fiksiranu signaturu \(\Sigma\).
Fiksiranje nekog proizvoljnog objekta je česta pojava u matematici,
prvenstveno zato što fiksiranjem ne trebamo spominjati argumente eksplicitno.
Coq omogućuje fiksiranje varijable naredbama \texttt{Variable} i \texttt{Context},
pod uvjetom da se korisnik nalazi u \texttt{Section} okolini.\footnote{\url{https://coq.inria.fr/doc/v8.18/refman/language/core/sections.html}}
Većina definicija i lema u ovom radu su napisane upravo unutar \texttt{Section} okoline.

\begin{definition}\label{def:term}
  \textit{Varijabla} je prirodan broj. Skup \textbf{terma} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item svaka varijabla je term;
  \item ako je \(f\) funkcijski simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi\footnote{Primijetimo, broj terma ovisi o mjesnosti funkcijskog simbola. U Coq implementaciji ovog ``konstruktora'' možemo vidjeti da je on zavisnog tipa.},
    onda je \(f(t_{1}, \ldots, t_{n})\) također term.
  \end{enumerate}
\begin{minted}{coq}
Inductive term : Type :=
| var_term : var -> term 
| TFunc : forall (f : FuncS Σ), vec term (fun_ar f) -> term.
\end{minted}
\end{definition}

Princip indukcije za \texttt{term} potrebno je ručno definirati.
Naime, induktivni tip \texttt{term} je \textit{ugniježđen} po konstruktoru \texttt{TFunc} što znači da se
javlja omotan oko drugog induktivnog tipa\footnote{Ovdje \texttt{vec}.} kao argument konstruktora.
Iako će Coq automatski generirati princip indukcije za \texttt{term}, taj princip neće biti \textit{prikladan}.
\begin{minted}{coq}
Lemma term_ind
     : forall P : term Σ -> Prop,
         (forall v, P (var_term v)) ->
         (forall f args, (forall st, V.In st args -> P st) ->
                         P (TFunc f args)) ->
       forall t : term Σ, P t.
\end{minted}

\begin{definition}
  Skup svih varijabli koje se javljaju u termu \(t\), u oznaci \(\mathit{TV}(t)\), konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item za varijablu \(v\) je \( \mathit{TV}(v) = \{ v \} \),
  \item za \(n\)-mjesni funkcijski simbol \(f\) i terme \(t_{1}, \ldots, t_{n}\) je \( \mathit{TV}(f(t_{1}, \ldots, t_{n})) = \bigcup_{1 \le i \le n} \mathit{TV}(t_{i}) \).
  \end{enumerate}
\begin{minted}{coq}
Inductive TV : term -> var -> Prop :=
| TVVar : forall v, TV (var_term v) v
| TVFunc : forall f args v st, V.In st args ->
                               TV st v -> TV (TFunc f args) v.
\end{minted}
\end{definition}

\begin{definition}
  \textbf{Supstitucija} je svaka funkcija iz skupa \(\mathbb{N}\) u skup terma.
  Supstitucije se mogu na prirodan način proširiti na skup terma.
\begin{minted}{coq}
Fixpoint subst_term  (σ : var -> term) (t : term) : term :=
  match t with
  | var_term v => σ v
  | TFunc f args => TFunc f (V.map (subst_term σ) args)
  end.
\end{minted}
\end{definition}

\begin{definition}\label{def:formula}
  Skup \textbf{formula} konstruiramo rekurzivno na način:
  \begin{enumerate}
  \item ako je \(Q\) običan ili induktivan predikatni simbol mjesnosti \(n\) te su \(t_{1}\), \ldots, \(t_{n}\) termi,
    onda je \(Q(t_{1}, \ldots, t_{n})\) \textit{atomarna} formula;
  \item ako je \(\varphi\) formula, onda su \(\neg\varphi\) i \(\forall\varphi\) također formule;
  \item ako su \(\varphi\) i \(\psi\) formule, onda je \(\varphi \rightarrow \psi\) također formula.
  \end{enumerate}
\begin{minted}{coq}
Inductive formula : Type :=
| FPred (P : PredS Σ) : vec (term Σ) (pred_ar P) -> formula 
| FIndPred (P : IndPredS Σ) : vec (term Σ) (indpred_ar P) -> formula 
| FNeg : formula -> formula 
| FImp : formula -> formula -> formula 
| FAll : formula -> formula.
\end{minted}
\end{definition}
\noindent Za univerzalnu kvantifikaciju odstupamo od tradicionalne defincije formule.
Umjesto kvantificiranja po eksplicitnoj varijabli,
mi ćemo implicitno kvantificirati po varijabli \(0\).
Ovaj pristup kvantifikaciji (ili općenitije, vezivanju varijabli), imena ``de Bruijnovo indeksiranje'', bitno olakšava rad sa supstitucijama, a uveden je u članku~\cite{debruijnamelessdummies}.
O samoj implementaciji de Bruijnovog indeksiranja više se može pročitati u knjizi
\textit{Types and Programming Languages}~\cite{pierce2002tapl}.
Za potrebe ovog rada koristili smo paket \textit{Autosubst2}\footnote{\url{https://github.com/uds-psl/autosubst2}} za automatsko generiranje tipova terma i formula te
pripadajućih funkcija supstitucija i pomoćnih lema.
\misao{Postojala je konfiguracijska datoteka za ovo. Ja to ne bih spominjao.}


Konačno, potrebno je definirati sintaksu za indukciju.
U Coqu su definicije induktivnih propozicija proizvoljne do na ograničenje pozitivnosti,
no radi jednostavnosti u \(\mathit{FOL_{ID}}\) su moguće samo
induktivne definicije sa atomarnim formulama, a pišemo ih u stilu prirodne dedukcije:
\begin{prooftree}
  \AxiomC{\(  Q_{1}\mathbf{u}_{1}  \ldots   Q_{n}\mathbf{u}_{n}  \)}
  \AxiomC{\(  P_{1}\mathbf{v}_{1}  \ldots   P_{m}\mathbf{v}_{m}  \)}
  \BinaryInfC{\(P\mathbf{t}\)}
\end{prooftree}
\noindent Ovdje su \(Q_{1}, \ldots, Q_{n}\) obični predikatni simboli, \(P_{1}, \ldots, P_{m}\) i \(P\) su induktivni predikatni simboli,
a podebljani znakovi predstavljaju vektore terma odgovarajućih duljina.

\begin{definition}
  \textbf{Produkcija} je uređena četvorka
  \begin{enumerate}
  \item liste običnih predikatnih simbola i vektora terma odgovarajućih duljina,
  \item liste induktivnih predikatnih simbola i vektora terma odgovarajućih duljina,
  \item induktivnog predikatnog simbola \(P\) mjesnosti \(n\) i
  \item vektora terma duljine \(n\).
  \end{enumerate}
\begin{minted}{coq}
Record production := mkProd {
    preds : list ({ P : PredS Σ & vec (term Σ) (pred_ar P) });
    indpreds : list ({ P : IndPredS Σ & vec (term Σ) (indpred_ar P) });
    indcons : IndPredS Σ;
    indargs : vec (term Σ) (indpred_ar indcons);
  }.
\end{minted}
  \textbf{Skup induktivnih definicija} je skup produkcija.
\begin{minted}{coq}
Definition IndDefSet := production -> Prop.
\end{minted}
\end{definition}



\section{Semantika}\label{sec:semantika}
\begin{definition}
  Struktura prvog reda \(M\) (kratko \textbf{struktura}) je uređena četvorka
  skupa kojeg nazivamo \textit{nosačem} te interpretacija funkcijskih,
  običnih predikatnih i induktivnih predikatnih simbola.
  Nosač označavamo sa \(|M|\). Funkcijski simboli se interpretiraju kao \(n\)-mjesne funkcije, a predikatni simboli kao \(n\)-mjesne relacije nad nosačem.
\begin{minted}{coq}
Structure structure := {
    domain : Type;
    interpF (f : FuncS Σ) : vec domain (fun_ar f) -> domain;
    interpP (P : PredS Σ) : vec domain (pred_ar P) -> Prop;
    interpIP (P : IndPredS Σ) : vec domain (indpred_ar P) -> Prop;
  }.
\end{minted}
\end{definition}
\noindent Kao i kod implementacije signature, nosač strukture ćemo predstaviti proizvoljnim tipom.
S druge strane, kada je riječ o skupovima kao predikatima (podskupovima), koristimo tipove
oblika \texttt{T\(\rightarrow\)\coqprop{}}.


\begin{definition}
  Neka je \(M\) proizvoljna struktura. \textbf{Okolina} \(\rho\) za \(M\) je proizvoljna funkcija iz skupa prirodnih brojeva u nosač strukture.
\begin{minted}{coq}
Definition env := var -> |M|.
\end{minted}
  Strukturalnom rekurzijom po termima možemo uz interpretaciju funkcijskih simbola proširiti okolinu na skup terma.
\begin{minted}{coq}
Fixpoint eval (ρ : env) (t : term Σ) : |M| :=
  match t with
  | var_term x => ρ x
  | TFunc f args => interpF f (V.map (eval ρ) args)
  end.
\end{minted}
\end{definition}

\begin{lemma}[Razumnost supstitucije za evaluaciju]\
\begin{minted}{coq}
Lemma eval_subst_sanity1 : forall (d : |M|),
    ~ TV t x -> eval_subst ρ t x d = eval ρ t.
\end{minted}
\begin{minted}{coq}
Lemma eval_subst_sanity2 : forall (u : term Σ),
    eval_subst ρ t x (eval ρ u) = eval ρ (term_var_subst t x u).
\end{minted}
\begin{minted}{coq}
Lemma eval_comp :
    forall (σ : var -> term Σ) (ρ : env M) t,
      eval (σ >> eval ρ) t = eval ρ (subst_term σ t).
\end{minted}
\end{lemma}

\begin{definition}[Relacija ispunjivosti]\
\begin{minted}{coq}
Fixpoint Sat (ρ : env M) (F : formula Σ) : Prop :=
  match F with
    | FPred P args => interpP P (V.map (eval ρ) args)
    | FIndPred P args => interpIP P (V.map (eval ρ) args)
    | FNeg G => ~ Sat ρ G
    | FImp F G => Sat ρ F -> Sat ρ G
    | FAll G => forall d, Sat (d .: ρ) G
  end.
\end{minted}
\end{definition}

\begin{lemma}[Rezumnost supstitucije za formule]\
\begin{minted}{coq}
Lemma form_subst_sanity1 :
  forall (Σ : signature) (F : formula Σ) (M : structure Σ)
    (ρ : env M) (d : |M|) (x : var),
    ~ FV F x -> (ρ ⊨ F <-> (env_subst ρ x d) ⊨ F).
\end{minted}
\begin{minted}{coq}
Lemma strong_form_subst_sanity2 :
    forall (Σ : signature) (F : formula Σ)
      (M : structure Σ) (ρ : env M)
      (σ : var -> term Σ),
      ρ ⊨ (subst_formula σ F) <-> (σ >> eval ρ) ⊨ F.
\end{minted}
\end{lemma}

\section{Standardni modeli}\label{sec:standardni-modeli}
Operator \(\varphi_{\Phi}\). Aproksimanti. Standardni model.

\section{Sistem sekvenata s induktivnim definicijama}\label{sec:sistem-sekvenata}
LKID. Dopustiva pravila. Primjeri dokaza.

\section{Adekvatnost}\label{sec:adekvatnost}
Lokalne adekvatnosti za pravila izvoda. Glavni teorem.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "master"
%%% End:
